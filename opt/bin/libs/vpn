#!/bin/sh
. /opt/apps/kvas/bin/libs/debug
. /opt/apps/kvas/bin/libs/ndm
. /opt/apps/kvas/bin/libs/adblock

# Убираем ошибки связанные с отсутствием /opt/etc/hosts
[ -f /opt/etc/hosts ] || touch /opt/etc/hosts
# ------------------------------------------------------------------------------------------
#
# 	Добавляет хосты в белый список, доступ к сайтам которого
#   осуществляется через Shadowsocks
#
#	Разработчик: mail@zeleza.ru
#	Дата: 21/05/2022
#	Лицензия: Apache License 2.0
#	75 функций (на 23/07/2022)
#	
# ------------------------------------------------------------------------------------------
#	Основные переменные для работы скрипта
# ------------------------------------------------------------------------------------------

DNS_IP_PORT="${LOCALHOST_IP}#${MAIN_DNS_PORT}"
CMD_LIST="address prefix name-servers"

# ------------------------------------------------------------------------------------------
#
# Обновляем таблицу iptable и правила в ней
#
# ------------------------------------------------------------------------------------------
update_iptables(){

    recreate_ip4tables

	if has_ssr_enable; then
		recreate_ssr_rules

	else
		recreate_vpn_rules
	fi
}

# ------------------------------------------------------------------------------------------
#
# Обновляем правила ipset
#
# ------------------------------------------------------------------------------------------
update_ipset(){
	stage="${1}"

	ready "${prefix}Заполняем ipset таблицу данными из списка разблокировки."
	/opt/apps/kvas/bin/main/ipset &> /dev/null &
	[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

	if [ -f /opt/etc/init.d/S56dnsmasq ] ; then
		refresh_dnsmasq_ipset_table
	else
		refresh_adguard_ipset_table
		[ "${stage}" = initd ] || {
			ready "${prefix}Перезапускаем сервис AdGuard Home"
			/opt/etc/init.d/S99adguardhome restart &>/dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
		}
	fi
}

# ------------------------------------------------------------------------------------------
#
# Обновляем правила adblock если этот режим включен
#
# ------------------------------------------------------------------------------------------
update_adblock(){

	if [ -f '/opt/etc/init.d/S56dnsmasq' ]; then
			if cat < '/opt/etc/dnsmasq.conf' | sed 's/^\(.*\)\(#.*\)/\2/; /^#/d; /^$/d' | grep -q "${ADBLOCK_HOSTS_FILE}" &> /dev/null; then
				ready "${prefix}Обновляем данные списка блокировки рекламы."
				/opt/apps/kvas/bin/main/adblock &>/dev/null && when_ok "ГОТОВО" || when_bad "ОШИБКА"
			fi
	fi
}

# ------------------------------------------------------------------------------------------
#
# Обновляем дату роутера с сервером времени
#
# ------------------------------------------------------------------------------------------
update_time(){
	ready "${prefix}Синхронизируем дату роутера с сервером времени."
	date_update &>/dev/null && when_ok "ГОТОВО" || when_bad "ОШИБКА"
}

# ------------------------------------------------------------------------------------------
#
# Производим перезапуск подключения к интернету
#
# ------------------------------------------------------------------------------------------
current_cli_vpn_interface() {
        inface_entware=$(get_config_value INFACE_ENT)
        inface=$(grep "${inface_entware}" "${INFACE_NAMES_FILE}"  | cut -d'|' -f1)
        echo "${inface}"
}

reset_all_connection(){

	ready "${prefix}Перезапускаем VPN и ISP соединения..."
	{
		if has_ssr_enable ; then
			/opt/etc/init.d/S22shadowsocks stop &>/dev/null
			# reset_ISP_connection
			/opt/etc/init.d/S22shadowsocks start &>/dev/null
		else
			inface=$(current_cli_vpn_interface)
			cli_request="localhost:79/rci/interface/${inface}"
#			curl -s -d '{"down":"true"}' "${cli_request}"  &>/dev/null
#			reset_ISP_connection
			curl -s -d '{"up":"true"}' "${cli_request}"  &>/dev/null
		fi
	} && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

}

# ------------------------------------------------------------------------------------------
#
# 	Производим инициализацию пакета КВАС
# 	$1 	- режим запуска функции имеет следующие значения:
#		update 		- режим обновления при выполнении kvas update
#		refresh 	- режим обновления списка доменов при командах add/del/import
#	    initd		- обновить время при установке пакета
# --------cmd_kvas_init----------------------------------------------------------------------------------
cmd_kvas_init(){

	stage="${1:-no}"
	prefix=''
	mess="${prefix}Производим сброс пакета КВАС в исходное состояние."
	warning "${mess}"
	print_line

#	Производим перезапуск подключения к интернету
#	если не режим update и если текущее подключение не ssr
	if [ "${stage}" = refresh ] || ! has_ssr_enable ; then
			reset_all_connection
	fi

	iptables_reset
	update_iptables
	update_ipset "${stage}"
	update_adblock

	ip4_add_route_table

#	ready "${prefix}Создаем таблицу маршрутизации ID#${TABLE_ID} для '$(inface_cli)'."
#	#	Создаем таблицу IP адресов для  VPN подключения отличного от shadowsocks
#
#	ip4_add_route_table &> /dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

	[ "${stage}" = initd ] && update_time || all_services_restart

	#log_alert "${prefix}Сброс пакета КВАС в исходное состояние ЗАВЕРШЕН!"

}


service_restart(){
	srv_name=${1}
	srv_initd=${2}
	ready "Перезапускаем ${srv_name}"
	if /opt/etc/init.d/${srv_initd} restart &> /dev/null; then
		when_ok "УСПЕШНО"
	else
		when_bad "ОШИБКА"
		error "Запустите диагностику командой kvas debug"
		exit 1
	fi
}

all_services_restart(){
	has_ssr_enable && service_restart  shadowsocks S22shadowsocks

	if has_adguard_enable; then
		service_restart AdGuardHome S99adguardhome
	else
		service_restart dnsmasq S56dnsmasq
		if [ "$(get_dns_crypt_status)" = on ]; then
			service_restart dnscrypt-proxy2 S09dnscrypt-proxy2
		fi
	fi

}



SUFF=">> "
# ------------------------------------------------------------------------------------------
#
#	Выводим предупреждение в случае, если пользователь
#	запускает команду для другого DNS сервиса и возвращаем
#	статус запущенной службы в случае, когда запущен именно AdGuard Home
#
# ------------------------------------------------------------------------------------------
exit_when_adguard_on(){
	if cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
		[ -z "${2}" ] && {
			echo -e "${SUFF}${BLUE}Сейчас функции DNS сервера, шифрования DNS трафика и функции блокировки рекламы ${NOCL}"
			echo -e "${SUFF}${BLUE}исполняет AdGuard Home, заменяющий связку [dnsmasq + dnscrypt_proxy2 + adblock].${NOCL}"
			echo -e "${SUFF}${BLUE}Единовременно Квас может работать только с одной из этих связок.${NOCL}"
			echo -e "${SUFF}${BLUE}Для перехода на связку с dnsmasq запустите команду ${GREEN}kvas adguard off${NOCL}"
		}
        eval "${1}=1";
    else
        eval "${1}=0";
    fi
}
exit_when_dnsmasq_on(){
	if ! cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
		[ -z "${2}" ] && {
			echo -e "${SUFF}${BLUE}Сейчас функции DNS сервера, шифрования DNS трафика и функции блокировки рекламы${NOCL}"
			echo -e "${SUFF}${BLUE}исполняет связка [dnsmasq + dnscrypt_proxy2 + adblock], заменяющая AdGuard Home.${NOCL}"
			echo -e "${SUFF}${BLUE}Единовременно Квас может работать только с одной из этих связок.${NOCL}"
			echo -e "${SUFF}${BLUE}Для перехода на AdGuard Home запустите команду ${GREEN}kvas adguard on${NOCL}"
		}
        eval "${1}=1";
    else
        eval "${1}=0";
    fi
}


ip4() (/opt/sbin/ip -4 "$@")
# ------------------------------------------------------------------------------------------
#
#	Функция вывода помощи по работе скрипта
#
# ------------------------------------------------------------------------------------------
cmd_help() {
	cat < "/opt/apps/${APP_NAME}/etc/conf/${APP_NAME}.help"
}



# ------------------------------------------------------------------------------------------
#
#	Получаем значение любого параметра заданного CLI интерфейса
#	$1 - ID CLI интерфейса с учетом регистра
#	$2 - название параметра
#
# ------------------------------------------------------------------------------------------
get_value_interface_field() {
	id_cli_inface=${1}
	field_name=${2}
	sleep 1
	curl -s "${INFACE_REQUEST}" | jq -r '.[] | select(.id=="'"${id_cli_inface}"'") | .'"${field_name}"
}
# ------------------------------------------------------------------------------------------
#
#	Получаем текущий интерфейс по умолчанию через который раздается интернет
#
# ------------------------------------------------------------------------------------------
get_defaultgw_interface() {
	curl -s "${INFACE_REQUEST}" | jq -r '.[] | select(.defaultgw==true and .global==true) | ."interface-name"'
}
# ------------------------------------------------------------------------------------------
#
#	Получаем текущий id по умолчанию через который раздается интернет
#
# ------------------------------------------------------------------------------------------
get_defaultgw_id() {
	curl -s "${INFACE_REQUEST}" | jq -r '.[] | select(.defaultgw==true and .global==true) | .id'
}

# ------------------------------------------------------------------------------------------
#
#	Функция вЫключения IPv6
#	$1 - CLI интерфейс
#
# ------------------------------------------------------------------------------------------
ipv6_inface_off() {

	inface="${1}"
	if [ -n "${inface}" ]; then
		ready "Поддержка IPv6 на интерфейсе ${inface} отключена"
		for cmd in ${CMD_LIST}; do
	#		для отключения инфейса необходимо отправить команду no
	#		по всем командам ipv6: address prefix name-servers
			curl -s -d '{"auto":true,"no":true}' "${INFACE_PART_REQUEST}/${inface}/ipv6/${cmd}" &> /dev/null
		done
		if [ $? = 0 ]; then when_ok "УСПЕШНО"; else when_bad "СБОЙ"; fi
	else
		when_bad "СБОЙ" && error "Не задан интерфейс"
	fi

}
# ------------------------------------------------------------------------------------------
#
#	Функция включения IPv6
#	$1 - CLI интерфейс
#
# ------------------------------------------------------------------------------------------
ipv6_inface_on() {
	inface="${1}"
#	Проверка на наличие заданного интерфейса в роутере
	if is_cli_inface_present "${inface}"; then
		if [ -n "${inface}" ]; then
			ready "Поддержка IPv6 на интерфейсе ${inface} подключена"
				for cmd in ${CMD_LIST}; do
		#		для отключения инфейса необходимо отправить команду auto
		#		по всем командам ipv6: address prefix name-servers
					curl -s -d '{"auto":true}' "${INFACE_PART_REQUEST}/${inface}/ipv6/${cmd}" &> /dev/null
				done
			if [ $? = 0 ]; then when_ok "УСПЕШНО"; else when_bad "СБОЙ"; fi
		else
			when_bad "СБОЙ" && error "Не задан интерфейс"
		fi
	else
		when_bad "СБОЙ" && error "Заданный интерфейс ${inface} не существует"
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Функция проверки статуса IPv6
#	$1 - CLI интерфейс
#	Возвращает:
#	0 - ipv6 подключен
#	1- ipv6 отключен
#	2 - ipv6 не совместим с указанным интерфейсом
#
# ------------------------------------------------------------------------------------------
ipv6_status() {
	inface="${1}"; res=0
	if [ -n "${inface}" ]; then
		for cmd in ${CMD_LIST}; do
			#		для отключения инфейса необходимо получить ответ true
			#		по всем командам ipv6: address prefix name-servers
			request=$(curl -s "${INFACE_PART_REQUEST}/${inface}/ipv6/${cmd}")
#			если интерфейс не совместим с IPV6, то выходим из цикла
			echo "${request}" | grep -q 'not IPv6 compatible' && res=-1 && break
			echo "${request}" | grep -q true && res=$((res+1))

		done
#		если вернем 1 - то IPv6 отключен
#		если вернем 0 - то IPv6 включен
#		если вернем 2 - то IPv6 несовместим с указанным интерфейсом
		[ "${res}" -eq 3 ] && echo 0
		[ "${res}" -eq -1 ] && echo 2
		[[ "${res}" -ge 0 ]] && [[ "${res}" -lt 3 ]] && echo 1

	else
		when_bad "СБОЙ"
		error "Не задан интерфейс"
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Функция проверки фактического наличия в списке доступного CLI интерфейса
#	$1 - CLI интерфейс
#
# ------------------------------------------------------------------------------------------
is_cli_inface_present() {
	inface="${1}"
	if [ -n "${inface}" ]; then
		curl -s "${INFACE_REQUEST}" | grep interface-name | grep -q "${inface}"
	else
		when_bad "СБОЙ"
		error "Не задан интерфейс"
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Функция проверки включен ли на заданном CLI интерфейсе поддержка IPv6
#	$1 - CLI интерфейс
#
# ------------------------------------------------------------------------------------------
ipv6_inface_status() {
	inface="${1}"
	if [ -n "${inface}" ]; then
		if is_cli_inface_present "${inface}" ; then
			ready "IPv6 на интерфейсе ${inface}"
			ipv6_status=$(ipv6_status "${inface}")
			[ "${ipv6_status}" -eq 0 ] && when_ok "ПОДКЛЮЧЕН"
			[ "${ipv6_status}" -eq 1 ] && when_alert "ОТКЛЮЧЕН"
			[ "${ipv6_status}" -eq 2 ] && when_bad "НЕ ВОЗМОЖЕН"
		else
			error "Указанный интерфейс ${inface} в системе не существует."
			exit 1
		fi
	else
		when_bad "СБОЙ"
		error "Не задан интерфейс"
		exit 1
	fi

}

# ------------------------------------------------------------------------------------------
#
#	 Меняем в файле конфигурации AdGuard Home DNS его адрес, в случае если он равен 0.0.0.0
# 	 Предотвращаем зависание работы пакета при выборе пользователем,
# 	 при первоначальной настройке AdGuard Home, опцию "все адреса"
#
# ------------------------------------------------------------------------------------------
adguardhome_change_and_get_config_ip() {
	ip_filter="[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}"
	ip_dns_adguard=$(cat < "${ADGUARDHOME_CONFIG}" | sed -n '/^dns/,/port:/p' | grep -o "${ip_filter}")
#	Если DNS порт установлен в значение 0.0.0.0 (все адреса), то меняем его на ip роутера
	if [ "${ip_dns_adguard}" = '0.0.0.0' ] ; then
		ip_dns_adguard=$(get_router_ip)
		sed -i '/^dns/,/port:/s/'"${ip_filter}/${ip_dns_adguard}"'/' "${ADGUARDHOME_CONFIG}"
	fi
	echo "${ip_dns_adguard}"
}

# ------------------------------------------------------------------------------------------
#
#	 Производим настройку работы AdGuard Home
# 	 $1 - содержит 'ip:port' для работы adguardhome
#
# ------------------------------------------------------------------------------------------
adguardhome_setup() {

	ip=$(adguardhome_change_and_get_config_ip)
	port=${MAIN_DNS_PORT}
	localhost="127.0.0.1"

	ready "AdGuard Home установлен в качестве основного DNS сервера"

#	в случае установленного dnsmasq останавливаем его и архивируем
	[ -f /opt/etc/init.d/S56dnsmasq ] && {
		/opt/etc/init.d/S56dnsmasq stop &> /dev/null
		mv -f /opt/etc/init.d/S56dnsmasq "${KVAS_BACKUP_PATH}"
	}
#	в случае наличия сервиса dnscrypt_proxy2 останавливаем его и архивируем
	[ -f /opt/etc/init.d/S09dnscrypt-proxy2 ] && {
		/opt/etc/init.d/S09dnscrypt-proxy2 stop &> /dev/null
		mv -f /opt/etc/init.d/S09dnscrypt-proxy2 "${KVAS_BACKUP_PATH}"
	}
#   останавливаем adg сервис, если он запущен
	${ADGUARDHOME_DEMON} stop &> /dev/null
#	устанавливаем DNS по умолчанию на ADGUARD
	set_config_value DNS_DEFAULT "${localhost}#${port}"
#	меняем номер порта в файле конфигурации adguard
	sed -i "s/\( port:\) .*/\1 ${port}/" "${ADGUARDHOME_CONFIG}"
#	если файл сервис adguard в наличии то архивируем файл конфигурации
	if [ -f "${ADGUARDHOME_DEMON}" ] && [ -f /opt/bin/AdGuardHome.yaml ]; then
		cp /opt/bin/AdGuardHome.yaml "${KVAS_BACKUP_PATH}"/AdGuardHome.yaml
		cp /opt/bin/AdGuardHome.yaml "${ADGUARDHOME_CONFIG}"
	fi
#	и копируем подготовленный файл сервиса adguard в папку запуска сервисов
#	проверяем файл на оригинальность (без переделок ли он под квас)
	if ! cat < "${ADGUARDHOME_DEMON}" | grep -q kvas ; then
#		если оригинальный, то архивируем его
		mv "${ADGUARDHOME_DEMON}" "${KVAS_BACKUP_PATH}/S99adguardhome.origin"
	fi
	cp /opt/apps/kvas/etc/init.d/S99adguard "${ADGUARDHOME_DEMON}"
#	удаляем сервис запуска квас так как его теперь будет заменять файл сервиса adguard
	rm -f "${KVAS_START_FILE}"
#	меняем dns в настройках ipset
	ipset_dns_change "${localhost}#${port}"

#	обязательно добавляем 127.0.0.1 в прослушку ADGUARDHOME
	sed -n '/bind_hosts:/,/port:/ p;' "${ADGUARDHOME_CONFIG}" | grep -qE "${localhost}"'|localhost' || \
		sed -i '/bind_hosts:/,/port:/ s/\(port:\)/  \- '"${localhost}"'\n  \1/' "${ADGUARDHOME_CONFIG}"

#	теперь просто запускаем сервис adguard
#	ndm_interface_change

#	Обновляем правила ip4tables для доступного соединения
	ip4_firewall_flush_all_rules
	ip4_firewall_set_all_rules

	"${ADGUARDHOME_DEMON}" start &> /dev/null
#	отслеживаем результат запуска сервиса adguard
	if [ $? = 0 ]; then
		when_ok "УСПЕШНО"
	else
		when_bad "СБОЙ";
		error "Возникла ошибка при установке AdGuard Home в качестве основного DNS сервера."
		print_line
		cat < "${ADGUARDHOME_LOG}" | tail
		exit 1
	fi
}
# ------------------------------------------------------------------------------------------
#
#	 Возвращаем IP#port на котором слушает AdGuard Home в качестве основного DNS сервера
#	 в виде XXX.XXX.XXX.XXX#53
#
# ------------------------------------------------------------------------------------------
get_adguardhome_ip_port() {
	ip_filter="[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}"
	ip_dns_adguard=$(cat < "${ADGUARDHOME_CONFIG}" | sed -n '/^dns/,/port:/p' | grep -o "${ip_filter}")
	echo "${ip_dns_adguard}" | grep -q '0.0.0.0' && dns_ip=$(get_router_ip)
	echo "${ip_dns_adguard}#${MAIN_DNS_PORT}"
}
# ------------------------------------------------------------------------------------------
#
#	 Возвращаем статус AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
cmd_adguardhome_status() {
	ready "Сервис AdGuard Home [$(grep address /opt/etc/AdGuardHome/AdGuardHome.yaml | cut -d":" -f2)]"
	# Проверяем наличие исполняемого файла AdGuardHome

	if [ -f /opt/bin/AdGuardHome ] ; then
#		Проверяем наличие файла конфигурации AdGuardHome
		if [ -f /opt/etc/AdGuardHome/AdGuardHome.yaml ] && grep -q 'kvas.ipset' /opt/etc/AdGuardHome/AdGuardHome.yaml; then
#			Проверяем наличие сервиса AdGuardHome
			if [ -f "${ADGUARDHOME_DEMON}" ] ; then
				if "${ADGUARDHOME_DEMON}" status | grep -q alive; then when_ok "ВКЛЮЧЕН"; else when_bad "ОТКЛЮЧЕН"; fi
			else
				when_bad "НУЖНО ПЕРЕУСТАНОВИТЬ"
			fi
		else
			when_bad "НЕ НАСТРОЕН"
		fi
	else
		when_bad "НЕ УСТАНОВЛЕН"
	fi

}
# ------------------------------------------------------------------------------------------
#
#	 Производим настройку AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
adguardhome_check_config() {
		# Проверяем наличие	архивной копии AdGuardHome
		if [ -f "${KVAS_BACKUP_PATH}"/AdGuardHome.yaml ]; then
			cp "${KVAS_BACKUP_PATH}"/AdGuardHome.yaml "${ADGUARDHOME_CONFIG}"
			"${ADGUARDHOME_DEMON}" restart  &> /dev/null
			ip=$(get_router_ip)
			port=$(cat < "${ADGUARDHOME_CONFIG}" | grep '^bind_port: ' | cut -d':' -f2 | tr -d ' \n')
			[ -z "${port}" ] && port="$(cat "${ADGUARDHOME_CONFIG}" | grep 'address:' | cut -d':' -f3)"
			warning "Был обнаружен и восстановлен архивный файл конфигурации AdGuard Home."
			warning "Панель управления находится по адресу: ${BLUE}http://${ip}:${port}${NOCL}"
			print_line
		else
			[ -f /opt/etc/init.d/S56dnsmasq ] && /opt/etc/init.d/S56dnsmasq stop &> /dev/null
			[ -f /opt/etc/init.d/S09dnscrypt-proxy2 ] && /opt/etc/init.d/S09dnscrypt-proxy2 stop &> /dev/null
			rm -f /opt/var/log/AdGuardHome.log
			rm -f /opt/etc/AdGuardHome/data/querylog.json

#			Проверяем наличие файла конфигурации AdGuardHome в папке исполняемых файлов
			if [ -f /opt/bin/AdGuardHome.yaml ]; then
#				проверяем файл на оригинальность (без переделок ли он под квас)
				if ! cat < "${ADGUARDHOME_DEMON}" | grep -q kvas ; then
#					если оригинальный, то архивируем его
					mv "${ADGUARDHOME_DEMON}" "${KVAS_BACKUP_PATH}/S99adguardhome.origin"
				fi

				cp /opt/apps/kvas/etc/init.d/S99adguard  /opt/etc/init.d/S99adguardhome
				cp /opt/bin/AdGuardHome.yaml "${ADGUARDHOME_CONFIG}"
#				"${ADGUARDHOME_DEMON}" restart  &> /dev/null
			fi
			error "Проверьте, что сеть WIFI/Ethernet, с которой Вы заходите на роутер - " no_nln
			error "та же самая, что и сеть с которой Вы открываете страницу браузера." no_nln
			print_line
			warning "Сейчас, перейдите на клиентское устройство в своем браузере "
			warning "и зайдите на страницу http://$(get_router_ip):3000 для настройки AdGuardHome"
			print_line
			warning "В поле 'Веб-интерфейс администрирования' выберите IP своего роутера выше"
			warning "В поле 'DNS-сервер' выберите пункт 'Все интерфейсы' и на следующем шаге"
			warning "введите имя и дважды пароль для входа в интерфейс AdGuardHome"
			warning "Далее, на следующей странице, нажмите на 'Открыть Панель Управления'."
			warning "После чего, установка AdGuard на роутере завершится автоматически."
			print_line

#			Совершенно новая установка пакета и его настройка
			[ -f "${ADGUARDHOME_CONFIG}" ] && rm -f "${ADGUARDHOME_CONFIG}"
			tmp_conf=/opt/tmp/adguard.conf
			log_file=/opt/tmp/adguard.log
			rm -f "${log_file}" "${tmp_conf}"
			touch "${log_file}"


#			Если случайно был уже запущен какой либо экземпляр процесса AdGuardHome, то удаляем его из памяти
			pid_to_kill=$(ps -w | grep 'AdGuardHome -l /opt/var/log/AdGuardHome.log' | grep -v 'grep' | cut -d' ' -f1)
			[ -n "${pid_to_kill}" ] && kill -9 "${pid_to_kill}" &> /dev/null
#			Запускаем новую чистую настройку AdGuardHome
			[ -f /opt/bin/AdGuardHome ] || opkg install adguardhome-go &> /dev/null
			/opt/bin/AdGuardHome -c "${tmp_conf}" -l "${log_file}" &
			sleep 2

			while true; do
				if cat < "${log_file}" | grep 'go to http' | grep -qv ':3000' || cat < "${log_file}" | grep -q ' listen tcp 0.0.0.0:3000: bind: address already in use' ; then
					killall AdGuardHome
					mv "${tmp_conf}" "${ADGUARDHOME_CONFIG}"
					adguardhome_setup
					print_line
					exit 0
				fi
				# Пауза в секундах между проверками
				sleep 1
			done

		fi
}
# ------------------------------------------------------------------------------------------
#
#	 Производим локальную установку AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
adguardhome_install_locally() {

	if [ -f /opt/tmp/opkg.lock ]; then
		echo "Установите AdGuard Home на роутер после завершения установки пакета"
		echo -e "Для этого наберите команду ${GREEN}opkg install adguardhome-go${NOCL}"
		echo "и следуйте рекомендациям на экране, после настройки AdGuard Home"
		echo "запустите команду ${GREEN}kvas adguard on${NOCL}."
	else
	
		[ -f /opt/etc/init.d/S56dnsmasq ] && /opt/etc/init.d/S56dnsmasq stop &> /dev/null
		[ -f /opt/etc/init.d/S09dnscrypt-proxy2 ] && /opt/etc/init.d/S09dnscrypt-proxy2 stop &> /dev/null
		rm -f /opt/var/log/AdGuardHome.log

		[ -f /opt/etc/hosts ] && cp /opt/etc/hosts "${KVAS_BACKUP_PATH}/hosts"

		opkg update &> /dev/null
		opkg remove adguardhome-go --force-depends &> /dev/null
		opkg install adguardhome-go --force-maintainer  &> /dev/null
		. /opt/apps/kvas/bin/libs/update
		cmd_adguard_update
		adguardhome_check_config
		adguardhome_setup
	fi
}

# ------------------------------------------------------------------------------------------
#
#	 Включаем работу AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
cmd_adguardhome_on() {

	status=$(cmd_adguardhome_status)
	if echo "${status}" | grep -q "НЕ УСТАНОВЛЕН" ; then
		error "Пакет AdGuard Home не установлен на роутере." no_newline
		print_line
		adguardhome_install_locally
#		fi
	elif echo "${status}" | grep -q "НЕ НАСТРОЕН" ; then
		adguardhome_check_config
		adguardhome_setup
	elif  echo "${status}" | grep -q "НУЖНО ПЕРЕУСТАНОВИТЬ" ; then
		adguardhome_install_locally
	else
		adguardhome_setup
	fi
#	восстанавливаем /opt/etc/hosts
	[ -f "${KVAS_BACKUP_PATH}/hosts" ] &&  cp -f "${KVAS_BACKUP_PATH}/hosts" /opt/etc/hosts
}
# ------------------------------------------------------------------------------------------
#
#	 Выключаем работу AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
cmd_adguardhome_off(){
	ready "AdGuard Home в качестве DNS сервера удален"
	[ -f "${ADGUARDHOME_CONFIG}" ] && sed -i "s/\( port:\) .*/\1 0/" "${ADGUARDHOME_CONFIG}"
	${ADGUARDHOME_DEMON} stop &> /dev/null
	[ -f "${ADGUARDHOME_CONFIG}" ] && mv -f "${ADGUARDHOME_CONFIG}" "${KVAS_BACKUP_PATH}/AdGuardHome.yaml"
	[ -f /opt/etc/init.d/S56dnsmasq ] && /opt/etc/init.d/S56dnsmasq stop &> /dev/null
	[ -f /opt/etc/init.d/S09dnscrypt-proxy2 ] && /opt/etc/init.d/S09dnscrypt-proxy2 stop &> /dev/null
	cp /opt/apps/kvas/etc/init.d/S96kvas "${KVAS_START_FILE}"
	dnsmasq_install '' &> /dev/null
	#	Обновляем правила ip4tables для доступного соединения
	ip4_firewall_flush_all_rules
	ip4_firewall_set_all_rules

	if [ $? = 0 ]; then
		when_ok "УСПЕШНО"
		dns_crypt_install ''
	else
		when_bad "С ОШИБКОЙ";
		error "Возникла ошибка при удалении AdGuard Home из системы."
		exit 1
	fi
}

# ------------------------------------------------------------------------------------------
#
#       Функция подключает гостевую сеть к активному vpn
#       $1 - ID гостевого моста в entware
#
# ------------------------------------------------------------------------------------------
bridge_vpn_access_del() {
        guest_bridge_id="${1}"
		_id=$(echo "${guest_bridge_id}" | sed 's/[a-z]//g')
		cli_inface=$(curl -s "${INFACE_REQUEST}" | jq -r '.[] | select(.address != null and .id == "'"Bridge${_id}"'") | .description')	    
		ready "Удаление гостевого интерфейса '${cli_inface}' завершено"
		{

#                ip4_firewall_rm_selected_guest_net "${guest_bridge_id}"
                #       Слушаем 53 порт гостевого интерфейса
                guest_net_ip=$(ip a | grep global | grep -E ' '"${guest_bridge_id}" | sed 's/inet \(.*\)\/.*/\1/' | tr -d ' ')
                if cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
        #               Если доступен ADGUARDHOME
                        sed -i -e '/bind_hosts/,/port/{ /- '"${guest_net_ip}"'/d }' "${ADGUARDHOME_CONFIG}"
#                       grep -v '    -'"${guest_net_ip}" /opt/tmp/agh.conf
#                       mv -f /opt/tmp/agh.conf "${ADGUARDHOME_CONFIG}"
                else
        #               Если сейчас работает только dnsmasq
                        sed -i -e '/listen-address/,/port/{ /listen-address='"${guest_net_ip}"'/d}' "${DNSMASQ_CONFIG}"
#                       grep -v 'listen-address='"${guest_net_ip}" "${DNSMASQ_CONFIG}" > /opt/tmp/dnsmasq.conf
#                       mv -f /opt/tmp/dnsmasq.conf "${DNSMASQ_CONFIG}"
                fi
        } && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}



# ------------------------------------------------------------------------------------------
#
#       Функция выводит список гостевых сетей в наличии
# ------------------------------------------------------------------------------------------
ikev2_include_to_list(){
        ikev2=$(curl -s "${LOCALHOST_IP}:79/rci/crypto/virtual-ip-server-ikev2")
        if [ -n "${ikev2}" ]; then
                net_pool=$(echo "${ikev2}" | grep pool-start | cut -d':' -f2 | sed 's/[\,\" ]//g;')
                echo "${ikev2}" | grep enable | grep -q true && status="ВКЛ. " || status="ОТКЛ."
		echo "${ikev2}" | grep enable | grep -q true && color="${GREEN}" || color="${RED}"
		txt="1. Сеть \"VPN-сервер\" IKEv2 [${net_pool}]"
		prn="$(join_ready "${txt}" "${status}" "${color}" $((LENGTH - MINUS)))"
                ready "${prn}"
                cat < "/opt/etc/kvas.conf" | grep 'INFACE_GUEST_ENT=' | grep -q "[^_]ikev2" && when_ok "ДОБАВЛЕНА" || when_alert "НЕ ДОБАВЛЕНА"
        fi

}

join_ready() {
	color=${3}
        size=$(diff_len "${1}" "${4}")
        printf "%b%-${size}s%b" "${1}"
      	echo -e ${color}${2}${NOCL}
}

guest_include_to_list(){
	num=${1}
	desc_full=${2}
	ent_inf=${3}

	echo "${desc_full}" | grep -q 'is up' && color=${GREEN} || color=${RED}
	echo "${desc_full}" | grep -q 'is up' && status="ВКЛ. " || status="ОТКЛ."

        _desc="$(echo "${desc_full}" | sed 's/^\(.*\) is.*$/\1/')"
#       отображаем все гостевые интерфейсы
	prn="$(join_ready "${num}. Сеть ${_desc}" "${status}" ${color} $((LENGTH - MINUS)))"
        ready "${prn}"
        cat < "/opt/etc/kvas.conf" | grep 'INFACE_GUEST_ENT=' | grep -q "[^_]${ent_inf}" && when_ok "ДОБАВЛЕНА" || when_alert "НЕ ДОБАВЛЕНА"
}

warning_info(){
	clear
	error "ВНИМАНИЕ!"
	print_line
	warning "Касается всех типов интерфейсов, кроме ${BLUE}IKEv2${NOCL} ${GREEN}и${NOCL} ${BLUE}WIFI${NOCL} ${GREEN}сетей.${NOCL}"
	warning "Прежде чем продолжить, подключите, каждый из них, в панели управления роутером!"
	error "Интерфейс должен быть подключен к серверу и иметь свой IP!" ln
	warning "В противном случае, он не будет отображаться в списке сетей."
	print_line
	echo "Если все сделали, нажмите любую клавишу."
	read -s -n 1
    clear
	print_line

}
cmd_bridge_vpn_access_list() {

	[ "${2}" = skip ] || {
		# warning_info
		echo "Полный список подключенных гостевых сетей:"
		print_line
	}

	wild="${1}"
	selected_vpn=$(get_config_value INFACE_CLI)
#       Список интерфейсов которые доступны в формате '"vps" [OpenVPN] -> 192.168.255.14 ВКЛ.'
#       или если адреса нет, то в формате '"Моя сеть" [SSTP] откл.'
	interfaces_json=$(curl -s "${INFACE_REQUEST}" )
#       Убираем основной мост Bridge0, все сети GigabitEthernet | Port | AccessPoint | WifiMaster | WifiStation
	interfaces_list=$(echo "${interfaces_json}" | jq -r '.[]
					| select(
						.address != null
						and .id != "'"${selected_vpn}"'"
						and .id != "Bridge0"
						and .type != "GigabitEthernet"
						and .type != "Port"
						and .type != "AccessPoint"
						and .type != "WifiMaster"
						and .type != "WifiStation"
						and .type != "Vlan"
					) | ("\"" + .description +
						"\" " + .type	+
						" [" + .address + "] " +
						" is " + .state)' )

        num=0
        #        Подключаем IKEv2 VPN-сервер
        if cat < "${KVAS_CONF_FILE}" | grep 'INFACE_GUEST_ENT=' | grep -qi ikev2; then
                if [ -z "${wild}" ] || [ "${wild}" = del ]; then
                        ikev2_item=$(ikev2_include_to_list)
                        [ -n "${ikev2_item}" ] && {
                        	echo "${ikev2_item}"
                        	num=1
                        }
                fi
        else
                if [ -z "${wild}" ] || [ "${wild}" = add ]; then
                        ikev2_item=$(ikev2_include_to_list)

                        [ -n "${ikev2_item}" ] && {
                        	echo "${ikev2_item}"
                        	num=1
                        }
                fi
        fi
        [ -n "${interfaces_list}" ] && {

			printf '%s\n' "${interfaces_list}" |
			while IFS= read -r desc_full ; do
			if echo "${desc_full}" | grep -q Bridge ; then
				net_ip=$(echo "${desc_full}" | sed 's/.*\[\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)\].*/\1/')
				ent_inf=$(ip a | grep global | grep "${net_ip}" | sed 's/.* \(.*\)$/\1/')
			else
				desc=$(echo "${desc_full}" | sed 's|\"\(.*\)\".*|\1|')
				ent_inf=$(cat /opt/etc/inface_equals | grep "${desc}" | cut -d'|' -f2)
			fi
				if cat < "${KVAS_CONF_FILE}" | grep 'INFACE_GUEST_ENT=' | grep -qi "${ent_inf}"; then

					if [ -z "${wild}" ] || [ "${wild}" = del ]; then
						num=$((num + 1))
						guest_include_to_list "${num}" "${desc_full}" "${ent_inf}"
					fi
				else
					if [ -z "${wild}" ] || [ "${wild}" = add ]; then
						num=$((num + 1))
						guest_include_to_list "${num}" "${desc_full}" "${ent_inf}"
					fi
				fi
			done
		}
}


# ------------------------------------------------------------------------------------------
#
#       Функция удаляет гостевую сеть из активного vpn
#
# ------------------------------------------------------------------------------------------
cmd_bridge_vpn_access_del() {

    guest_bridge_id=''; bridge_inface_select guest_bridge_id del

	if [ -n "${guest_bridge_id}" ]; then
#			проверяем, есть ли в списке ikev2
		if echo "${guest_bridge_id}" | grep -iq ikev2 ; then
			ikev2_net_access_del
		else
			bridge_vpn_access_del "${guest_bridge_id}"
			sed -i '/INFACE_GUEST_ENT=/,/^$/ s/'"${guest_bridge_id}"'[,]\{0,1\}//; s/[ ,]//g' "${KVAS_CONF_FILE}"
		fi
		ready "Перезапускаем DNS сервер"
		if cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
			/opt/etc/init.d/S99adguardhome restart &> /dev/null
		else
			/opt/etc/init.d/S56dnsmasq restart &> /dev/null
		fi
		[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"

	fi

	

}


# ------------------------------------------------------------------------------------------
#
#       Функция подключает гостевую сеть к активному vpn
#       $1 - ID гостевого моста в entware
#
# ------------------------------------------------------------------------------------------
bridge_access_add() {

        guest_bridge_id=${1}; 
# set -xe
		_id=$(echo "${guest_bridge_id}" | sed 's/[a-z]//g')
		cli_inface=$(curl -s "${INFACE_REQUEST}" | jq -r '.[] | select(.address != null and .id == "'"Bridge${_id}"'") | .description')	    
		ready "Добавление гостевого интерфейса '${cli_inface}' завершено"
# set +xe
#		если сеть уже есть в списке, то пропускаем добавление
		grep INFACE_GUEST_ENT "${KVAS_CONF_FILE}" | grep -q "${guest_bridge_id}" || {
			has_guest_nets=$(cat <  "${KVAS_CONF_FILE}" | sed -n 's/INFACE_GUEST_ENT=\(.*\)/\1/p')
			[ -n "${has_guest_nets}" ] && point=',' || point=''
			sed -i "s/\(INFACE_GUEST_ENT=.*\)/\1${point}${guest_bridge_id}/g; s/[ ]//g" "${KVAS_CONF_FILE}"
		}

#       Слушаем 53 порт гостевого интерфейса
        guest_net_ip=$(ip a | grep global | grep -E ' '"${guest_bridge_id}" | sed 's/inet \(.*\)\/.*/\1/' | tr -d ' ')
        if cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
#           Если доступен ADGUARDHOME
			grep -q "\- ${guest_net_ip}" "${ADGUARDHOME_CONFIG}" || \
				sed -i '/bind_hosts/,/port/ s/.*\(port.*\)/    - '"${guest_net_ip}"'\n  \1/1' "${ADGUARDHOME_CONFIG}"
        else
#           Если сейчас работает только dnsmasq
			grep -q "listen-address=${guest_net_ip}" "${DNSMASQ_CONFIG}" || \
				sed -i '/listen-address/,/port/ s/.*\(port.*\)/listen-address='"${guest_net_ip}"'\n\1/' "${DNSMASQ_CONFIG}"

        fi
        [ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}


bridge_vpn_access_add() {
	guest_bridge_id=${1}

	if [ -n "${guest_bridge_id}" ]; then
		if echo "${guest_bridge_id}" | grep -iq ikev2 ; then
			ikev2_net_access_add
		else
			bridge_access_add "${guest_bridge_id}"

			if has_ssr_enable; then
				ip4_add_selected_guest_to_ssr_network "${guest_bridge_id}"
			fi
		fi
	fi
}

# ------------------------------------------------------------------------------------------
#
#       Обертка вокруг функции добавления гостевых сетей к активному vpn
#
# ------------------------------------------------------------------------------------------
cmd_bridge_vpn_access_add() {

#       Если добавляем конкретный интерфейс
	guest_bridge_id=''; bridge_inface_select guest_bridge_id add

	if [ -n "${guest_bridge_id}" ]; then
		bridge_vpn_access_add "${guest_bridge_id}"

	#       перезапускаем DNS сервер новыми IP для прослушки на 53 порту
		ready "Перезапускаем DNS сервер"
		if cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
			/opt/etc/init.d/S99adguardhome restart &> /dev/null
		else
			/opt/etc/init.d/S56dnsmasq restart &> /dev/null
		fi
		[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
	fi
}



# ------------------------------------------------------------------------------------------
#
#       Функция подключает гостевую сеть к активному vpn
#       $1 - переменная для записи ID гостевого моста в entware
#
# ------------------------------------------------------------------------------------------
bridge_inface_select() {
    action="${2}"
    entware_list=$(cmd_bridge_vpn_access_list "${action}" skip)
	echo "${action}" | grep -q "add" && act="добавления" || act="удаления"

    if [ -n "${entware_list}" ]; then
       	echo "Выберите гостевую сеть для ${act}:"
      	print_line
        echo "${entware_list}"
        total=$(echo -e "${entware_list}" | wc -l)

    	while true; do
			print_line
			echo -en "Выберите номер интерфейса [1-${total}, Q-выход]:  "
			read -r num_inface
			case "${num_inface}" in
				[qQ]*) break ;;
				[1-${total}]* )
					print_line
					if [ "${num_inface}" = 1 ] && echo "${entware_list}" | grep -iq ikev2 ; then
						eval "${1}=ikev2" ;
					else
						net_ip=$(echo "${entware_list}" | sed -n "${num_inface}"'p' | sed 's/.*\[\([0-9]\{1,3\}.[0-9]\{1,3\}.[0-9]\{1,3\}.[0-9]\{1,3\}\)\].*/\1/')
						eval "${1}=$(get_inface_by_ip ${net_ip})" ;
					fi
					break ;;
				* ) print_line; error "Введите цифру от 1 до ${total}." nl ;;
			esac
    	done
    else
        warning "Гостевые интерфейсы для ${act} отсутствуют!"
    fi
}


# ------------------------------------------------------------------------------------------
#
#	Меняем текущий DNS в настройках ipset на новый
#
#	$1 - новый DNS
#
# ------------------------------------------------------------------------------------------
ipset_dns_change() {
	dns_new=${1};
	if echo "${dns_new}" | grep -qE ':|#'; then
		_dns_clear=$(echo "${dns_new}" | tr '#' ':' )
		sed -i "s/@[a-zA-Z0-9:.]*/@${_dns_clear}/" "/opt/apps/kvas/bin/main/ipset"
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Устанавливаем поддержку обработку субдоменнов (wildcard) для dnsmasq
#
# ------------------------------------------------------------------------------------------

dnsmasq_install_wildcard_support(){
	ready "Меняем dnsmasq на версию с поддержкой wildcard"
	bin_path="/opt/apps/kvas/sbin/dnsmasq"
	chmod -R +x "${bin_path}"
	arch=$(grep "arch" /opt/etc/entware_release | cut -f2 -d"=")
	case "${arch}" in
		mips) cp ${bin_path}/mips /opt/sbin/dnsmasq 1> /dev/null 2> "${ERROR_LOG_FILE}";;
		mipsel) cp ${bin_path}/mipsel /opt/sbin/dnsmasq 1> /dev/null 2> "${ERROR_LOG_FILE}";;
		aarch64) cp ${bin_path}/aarch64 /opt/sbin/dnsmasq 1> /dev/null 2> "${ERROR_LOG_FILE}";;
		*) 	when_bad "ОШИБКА"
			mess="Неизвестная архитектура процессора: ${arch}!"
			warning "${mess}"
			log_in_file "ОШИБКА: ${mess}"
			exit 1
		;;
	esac
	ready_status "${?}" "Проблема при замене dnsmasq на версию с поддержкой wildcard"
}


# ------------------------------------------------------------------------------------------
#
#	Устанавливаем dnsmasq в систему
#
#	$1 - наличие значения данной переменной говорит о том,
#	что вызов данной функции был произведен при инсталляции пакета
#
# ------------------------------------------------------------------------------------------
dnsmasq_install(){
	is_install_stage="${1}"

	if [ -f /opt/etc/init.d/K56dnsmasq ]; then
		cp /opt/etc/init.d/K56dnsmasq /opt/etc/init.d/S56dnsmasq
	else
		if ! [ -f "/opt/etc/init.d/S56dnsmasq" ]; then
			ready "Устанавливаем пакет dnsmasq..."
			if ! [ -f /opt/etc/init.d/S56dnsmasq ]; then
#				то в этом случае можем попытаться удалять или устанавливать пакеты
				opkg update 1> /dev/null 2> "${ERROR_LOG_FILE}"
				opkg remove dnsmasq-full --force-depends 1> /dev/null 2> "${ERROR_LOG_FILE}"
				opkg install dnsmasq-full --force-maintainer 1> /dev/null 2> "${ERROR_LOG_FILE}"
				when_error "${?}" "Ошибка при установке пакета dnsmasq"
			fi
		fi
	fi
	if /opt/etc/init.d/S56dnsmasq status | grep -q alive ; then
		ready "Останавливаем сервис dnsmasq..."
		/opt/etc/init.d/S56dnsmasq stop 1> /dev/null 2> "${ERROR_LOG_FILE}"
		ready_status "${?}" "Невозможно остановить сервис dnsmasq"
	fi
	ready "Заменяем файл конфигурации dnsmasq...   "
	[ -f /opt/etc/dnsmasq.conf ] && mv -f /opt/etc/dnsmasq.conf "${KVAS_BACKUP_PATH}/dnsmasq.conf" 1> /dev/null 2> "${ERROR_LOG_FILE}"
	cp /opt/apps/kvas/etc/conf/dnsmasq.conf /opt/etc/dnsmasq.conf 1> /dev/null 2> "${ERROR_LOG_FILE}"
	ready_status "${?}" "Проблемы при замене в файле конфигурации dnsmasq"

	dnsmasq_install_wildcard_support

	uplevel_dns=$(get_config_value DNS_DEFAULT)
	local_ip=$(get_router_ip)
	inface=$(get_inface_by_ip "${local_ip}")

	ready "Настройка файлов конфигурации dnsmasq"
	sed -i "s/@LOCAL_IP/${local_ip}/g; s/@INFACE/${inface}/g; s/@UPLEVEL_DNS/${uplevel_dns}/g;" /opt/etc/dnsmasq.conf 1> /dev/null 2> "${ERROR_LOG_FILE}"
	ready_status "${?}" "Проблема при настройке файлов конфигурации dnsmasq"
	# Если запуск функции был не при установке пакета Квас
	[ -z "${is_install_stage}" ] && cmd_kvas_init "no"

}

# ------------------------------------------------------------------------------------------
#
#	Меняем текущий DNS на dnsmasq на новый
#
#	$1 - новый DNS
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
dnsmasq_dns_change() {
	dns_new=${1}; cmd=${2:-restart};
	ready "Замена DNS на ${dns_new} в dnsmasq завершена"
	sed -i "s/\(server=\).*/\1${dns_new}/"  "${DNSMASQ_CONFIG}"
	ipset_dns_change "${dns_new}"
	set_config_value DNS_DEFAULT "${dns_new}"
	/opt/etc/init.d/S56dnsmasq restart &> /dev/null
#	[ "${cmd}" = restart ] && cmd_update_list &> /dev/null
	[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}
# ------------------------------------------------------------------------------------------
#
#	Меняем текущий DNS на dnsmasq на новый
#
#	$1 - новый DNS
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
cmd_dnsmasq_dns_change() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {
		dns_new=${1}; cmd=${2:-restart}
		if [ -z "${dns_new}" ]; then
			dns_show
		else
			dnsmasq_dns_change "${dns_new}" "${cmd}"
		fi
	}
}

# ------------------------------------------------------------------------------------------
#
#	Отображаем текущий IP, который слушает в dnsmasq
#
# ------------------------------------------------------------------------------------------
cmd_dnsmasq_listen_show() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {
		ready "DNSMASQ слушает адрес:порт"
		ip=$(get_config_value DNSMASQ_LISTEN_IP)
		when_alert "${ip}:$(cmd_adguardhome_status)"
	}
}


# ------------------------------------------------------------------------------------------
#
#	Меняем текущий порт dnsmasq на новый
#
# 	$1 - новый номер порта
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
cmd_dnsmasq_port_change() {

	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		port=${1}; cmd=${2:-restart}
		if [ -z "${port}" ]; then
			cmd_dnsmasq_port_show
		else
			ready "Замена порта на ${port} в dnsmasq завершена"
			sed -i "s/\(port=\).*/\1${port}/"  "${DNSMASQ_CONFIG}"
			set_config_value DNSMASQ_PORT "${port}"
			[ "${cmd}" = restart ] && cmd_kvas_init "no" &> /dev/null
			[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
		fi
	}
}
# ------------------------------------------------------------------------------------------
#
#	Отображаем текущий порт, который слушает в dnsmasq
#
# ------------------------------------------------------------------------------------------
cmd_dnsmasq_port_show() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		ready "DNSMASQ слушает порт"
		port=$(get_config_value DNSMASQ_PORT)
		when_alert "${port}"
	}
}

# ------------------------------------------------------------------------------------------
#
#	Отображаем текущий DNS, установленный в dnsmasq
#
# ------------------------------------------------------------------------------------------
cmd_dns_test() {
	domain=${1:-google.com}
	ready "Тестируем получение адреса домена ${domain}"
	result=$(test_host "${domain}" ip)
	[ -n "${result}" ] && when_alert "${result}" || when_bad "ПУСТО"
}
# ------------------------------------------------------------------------------------------
#
#	Отображаем текущий DNS, установленный в dnsmasq
#
# ------------------------------------------------------------------------------------------
dns_show() {
	mess="Текущий DNS сервер по умолчанию"
	if cmd_adguardhome_status | grep -qE "ВКЛЮЧЕН|ОТКЛЮЧЕН" ; then
		DNS_IP_PORT=$(get_adguardhome_ip_port)
	fi
	dns=$(get_config_value DNS_DEFAULT)
	dns_crypt=$(get_config_value DNS_CRYPT_PORT)
	if  echo "${dns}" | grep -q "${dns_crypt}" ; then
		mess="${mess} (dnscrypt_proxy2)"
	elif echo "${dns}" | grep -q "${DNS_IP_PORT}" ; then
		mess="${mess} (AdGuard Home)"
	else
		mess="${mess} (dnsmasq)"
	fi
	ready "${mess}"; when_alert "${dns}"
}


# ------------------------------------------------------------------------------------------
#
#	ВКЛючаем VPN клиента
#	$1 - id интерфейса в entware
#
# ------------------------------------------------------------------------------------------
vpn_off() {
#	ready "Интерфейс vpn отключен "
	rm -f "/opt/etc/ndm/netfilter.d/100-vpn-mark"
	[ -f /opt/etc/ndm/ifstatechanged.d/100-unblock-vpn ] && rm -f /opt/etc/ndm/ifstatechanged.d/100-unblock-vpn
	[ -f /opt/etc/ndm/iflayerchanged.d/100-unblock-vpn ] && rm -f /opt/etc/ndm/iflayerchanged.d/100-unblock-vpn
	rm -f "/opt/etc/ndm/fs.d/100-vpn"
	cmd_vpn_iptable_flush  &> /dev/null
}
# ------------------------------------------------------------------------------------------
#
#	Отображаем статус VPN подключения (тип соединения и его состояние)
#
# ------------------------------------------------------------------------------------------
cmd_vpn_status() {
        vpn_cli_desc=$(get_current_vpn_interface "cli_desc")
        vpn_cli=$(get_current_vpn_interface "cli")
        [ "${vpn_cli}" = 'shadowsocks' ] && inface="SHADOWSOCKS" || inface="${vpn_cli_desc} (${vpn_cli})"
        ready "Текущее VPN соединение: ${BLUE}${inface}${NOCL}"
        [ "$(is_vpn_interface_connected "${vpn_cli}")" = 'on' ] && when_ok "ПОДКЛЮЧЕНО" || when_bad "ОТКЛЮЧЕНО"
}
# ------------------------------------------------------------------------------------------
#
#	Производим замену в библиотеке ndm основных значения интерфейсов
#	$1 - id интерфейса в entware
#
# ------------------------------------------------------------------------------------------
ndm_interface_change() {
	inface_entware="${1}"; inface_cli="${2}"
	cp /opt/apps/${APP_NAME}/etc/ndm/ndm /opt/apps/kvas/bin/libs/ndm
	chmod +x /opt/apps/kvas/bin/libs/ndm
	set_config_value "INFACE_ENT" "${inface_entware}"
	set_config_value "INFACE_CLI" "${inface_cli}"

}
# ------------------------------------------------------------------------------------------
#
#	ВКЛючаем VPN клиента
#	$1 - id интерфейса в entware
#
# ------------------------------------------------------------------------------------------
vpn_on() {

	inface_entware="${1}"
	inface_cli=$(grep "${inface_entware}" "${INFACE_NAMES_FILE}" | cut -d '|' -f1 )
	inface_cli_desc=$(grep "${inface_entware}" "${INFACE_NAMES_FILE}" | cut -d '|' -f3 )

	ready "Интерфейс ${inface_cli_desc} подключен "
	{

		cp "/opt/apps/${APP_NAME}/etc/ndm/fs.d/100-vpn" "/opt/etc/ndm/fs.d/100-vpn"
		chmod +x "/opt/etc/ndm/fs.d/100-vpn"
	#	Производим замену в библиотеке ndm основных значения интерфейсов
		ndm_interface_change "${inface_entware}" "${inface_cli}"

		cp "/opt/apps/${APP_NAME}/etc/ndm/netfilter.d/100-vpn-mark" "/opt/etc/ndm/netfilter.d/100-vpn-mark"
		chmod +x "/opt/etc/ndm/netfilter.d/100-vpn-mark"

#		Если версия фирменной оболочки равно или больше 4.0,
#		то применяем механизм iflayerchanged.d, если нет, то ifstatechanged.d
		hook_dir=$(get_hook_dir)
		cp "/opt/apps/${APP_NAME}/etc/ndm/${hook_dir}/100-unblock-vpn" "/opt/etc/ndm/${hook_dir}/100-unblock-vpn"
		chmod +x "/opt/etc/ndm/${hook_dir}/100-unblock-vpn"

		state=$(get_value_interface_field "${inface_cli}" state)

		if [ "${state}" = 'down' ]; then
			curl -s -d '{"up":"true"}' "${INFACE_PART_REQUEST}/${inface_cli}" &> /dev/null
		fi
		sleep 2
#		connected=$(get_value_interface_field "${inface_cli}" connected)
		connected=$(get_value_interface_field "${inface_cli}" state)

#		if [ "${connected}" = 'no' ]; then
		if [ "${connected}" = 'down' ]; then

			when_bad "С ОШИБКАМИ"
			error "Возникла ошибка при подключении интерфейса ${inface_entware}!"
			error "Проверьте доступность сервера и настройки клиента!"
			exit 1
		else
			recreate_ip4tables
			recreate_vpn_rules
		fi
	} 1> /dev/null 2> "${ERROR_LOG_FILE}"
	ready_status "${?}" "Возникла ошибка при подключении VPN соединения [${inface_cli_desc}]" "УСПЕШНО"

}

active_backup_config(){
	echo "Обнаружен архивный файл конфигурации shadowsocks."
	answer=''; read_ynq_timer "Удалить его и создать новый" answer N 6
	if [ "${answer}" = q ] ; then exit_q; exit 1; fi
	if echo "${answer}" | grep -qi y ; then
		ready "Удаляем архивный файл конфигурации shadowsocks..."
		rm -f "${SHADOWSOCKS_CONF}.kvas"
		[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
	else
		ready "Восстанавливаем файл конфигурации shadowsocks из архива   "
		cp "${SHADOWSOCKS_CONF}.kvas" "${SHADOWSOCKS_CONF}"  &>/dev/null
		if [ ${?} = 0 ]; then
			when_ok "УСПЕШНО";
		else
			when_bad "ОШИБКА" && exit 1
		fi
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Сохраняем данные для shadowsocks в архивный файл ${SHADOWSOCKS_CONF}.kvas
#
# ------------------------------------------------------------------------------------------
shadowsocks_backup() {
	# Проверяем установлен ли сервис shadowsocks
	if [ -f /opt/bin/ss-redir ] && [ -f /opt/etc/init.d/S22shadowsocks ]; then
		# меняем данные в файлах shadowsocks
		sed -i 's/ss-local/ss-redir/g' /opt/etc/init.d/S22shadowsocks

	#	Проверяем на наличие запуска сервиса shadowsocks
		if /opt/etc/init.d/S22shadowsocks status | grep -q alive ; then
			print_line
			ready "Останавливаем сервис shadowsocks..."
			if /opt/etc/init.d/S22shadowsocks stop &>/dev/null; then
				when_ok "УСПЕШНО"
			else
				when_bad "ОШИБКА"
				error "Невозможно остановить сервис shadowsocks"
				exit 1
			fi
		fi
		if [ -f "${SHADOWSOCKS_CONF}" ] ; then
			grep -qE '""|@|127.0.0.1|barfoo!' "${SHADOWSOCKS_CONF}" && shadowsocks_read_config
		else
			if [ -f "${SHADOWSOCKS_CONF}.kvas" ] && grep -qvE '""|@|127.0.0.1|barfoo!' "${SHADOWSOCKS_CONF}" ; then
				active_backup_config
			else
				shadowsocks_read_data
			fi
		fi
	else
		error "Shadowsocks сервис не установлен. Дальнейшая установка невозможна."
		exit 1;
	fi
}


get_ssr_entware_interface()(ip4 a | grep "${SSR_ENTWARE_TEMPL}" | head -1 | cut -d': ' -f2 | tr -d ' ')


shadowsocks_read_config(){

	SSR_SERVER_IP=""; SSR_SERVER_PORT=""; SSR_SERVER_CRYPT=""; SSR_SERVER_PASSWD=""

	read_value "Ведите доменное имя или IP адрес сервера:" SSR_SERVER_IP
	[ "${SSR_SERVER_IP}" = q ] && exit 1
	read_value "Ведите порт сервера:" SSR_SERVER_PORT 'digit'
	[ "${SSR_SERVER_PORT}" = q ] && exit 1
	read_value "Ведите метод шифрования на стороне сервера:" SSR_SERVER_CRYPT
	[ "${SSR_SERVER_CRYPT}" = q ] && exit 1
	read_value "Ведите пароль сервера:" SSR_SERVER_PASSWD 'password'
	[ "${SSR_SERVER_PASSWD}" = q ] && exit 1
	echo

	if [ -f "${SHADOWSOCKS_CONF}" ] ; then
		sed -i "s/\(\"server\":\).*/\1 \"${SSR_SERVER_IP}\",/; 			\
				s/\(\"server_port\":\).*/\1 ${SSR_SERVER_PORT},/; 		\
				s/\(\"local_port\":\).*/\1 $(get_config_value SSR_DNS_PORT),/; 		\
				s/\(\"password\":\).*/\1 \"${SSR_SERVER_PASSWD}\",/; 	\
				s/\(\"method\":\).*/\1 \"${SSR_SERVER_CRYPT}\",/;" 		\
			"${SHADOWSOCKS_CONF}"
	else
		print_line
		error "Не обнаружен файл ${SHADOWSOCKS_CONF}." nl
		print_line
		exit 0
	fi
}

shadowsocks_config_check(){
	ss-redir  -c "${SHADOWSOCKS_CONF}" 2>/dev/null &
	id=$(ps -w | grep 'ss-redir -c '"${SHADOWSOCKS_CONF}" | grep -v grep | cut -d' ' -f1)
	if [ -n "${id}" ] ; then
		kill -9 "${id}"
	else
		error "Обнаружены ошибки в файле конфигурации ${SHADOWSOCKS_CONF}" nl
		print_line
		ss-redir  -c "${SHADOWSOCKS_CONF}"
		print_line
		exit 0
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Меняем данные для shadowsocks соединения
#
# ------------------------------------------------------------------------------------------
cmd_shadowsocks_read_new_data() {

	echo "Для смены shadowsocks сервера необходимо ввести следующие данные:"
	echo -e "${GREEN}Хост или IP${NOCL} shadowsocks сервера, его ${GREEN}порт, пароль доступа${NOCL} и ${GREEN}метод шифрования${NOCL}"

	echo -e "${BLUE}Пожалуйста, последовательно введите эти данные ниже.${NOCL}"
	print_line

	shadowsocks_read_data
	shadowsocks_config_check &>/dev/null

	service_restart  shadowsocks S22shadowsocks

#	ready "Перезапускаем shadowsocks интерфейс"
#	/opt/etc/init.d/S22shadowsocks restart &> /dev/null
#	/opt/etc/init.d/S22shadowsocks status &> /dev/null
#	if [ $? = 0 ]; then
#		when_ok "УСПЕШНО"
#	else
#		when_bad "ОШИБКА"
#		error "Возникла ошибка при подключении shadowsocks интерфейса!"
#		error "Проверьте доступность сервера и настройки клиента!"
#		exit 1
#	fi

}


shadowsocks_read_link(){


	SSR_LINK=""; SSR_SERVER_IP=""; SSR_SERVER_PORT=""; SSR_SERVER_CRYPT=""; SSR_SERVER_PASSWD=""

	read_value "Ведите кодированную ссылку в формате ss://:" SSR_LINK
	[ "${SSR_LINK}" = q ] && exit 1

	if [[ -n "${SSR_LINK}" && "${#SSR_LINK}" -gt 6 ]] ; then
		SSR_LINK="$(echo ${SSR_LINK}" | sed -E 's/(.*)[#?\/]\?.*|(.*)#.*/\1\2/')"
		password=$(echo "${SSR_LINK}" | grep -oP "(?<=ss://).*?(?=@)" | base64 -d )
		SSR_SERVER_PASSWD=$(echo "${password}" | cut -d ":" -f 2)
		SSR_SERVER_CRYPT=$(echo "${password}" | cut -d ":" -f 1)
		SSR_SERVER_IP=$(echo "${SSR_LINK}" | grep -oP "(?<=@).*?(?=:)")
		SSR_SERVER_PORT=$(echo "${SSR_LINK}" | cut -d ":" -f 3 | cut -d "#" -f 1)
	else
		error "Ссылка пуста или слишком коротка! Введите корректную ссылку!"  nl
		exit 1
	fi
	if [ -z "${SSR_SERVER_PASSWD}" ] || [ -z "${SSR_SERVER_CRYPT}" ] || [ -z "${SSR_SERVER_IP}" ] || [ -z "${SSR_SERVER_PORT}" ] ; then
		error "Извлеченные данные не корректны! Введите ссылку с корректными данными!"  nl
		exit 1
	else

		if [ -f "${SHADOWSOCKS_CONF}" ] ; then
			sed -i "s/\(\"server\":\).*/\1 \"${SSR_SERVER_IP}\",/; 			\
					s/\(\"server_port\":\).*/\1 ${SSR_SERVER_PORT},/; 		\
					s/\(\"local_port\":\).*/\1 $(get_config_value SSR_DNS_PORT),/; 		\
					s/\(\"password\":\).*/\1 \"${SSR_SERVER_PASSWD}\",/; 	\
					s/\(\"method\":\).*/\1 \"${SSR_SERVER_CRYPT}\",/;" 		\
				"${SHADOWSOCKS_CONF}"
		else
			print_line
			error "Не обнаружен файл ${SHADOWSOCKS_CONF}." nl
			print_line
			exit 0
		fi
	fi
}


# ------------------------------------------------------------------------------------------
#
#	Отключаем shadowsocks клиента
#
# ------------------------------------------------------------------------------------------
shadowsocks_read_data() {

	#	устанавливаем новую конфигурацию shadowsocks
	cp -f "/opt/apps/${APP_NAME}/etc/conf/shadowsocks.json" "${SHADOWSOCKS_CONF}"

	answer=''; read_ynq "У Вас имеется кодированная ss:// ссылка для ввода данных" answer
	if [ "${answer}" = q ] ; then exit_q; exit 1; fi

	{
		if echo "${answer}" | grep -qi y ; then
			shadowsocks_read_link
		else

			echo "Чтобы продолжить работу необходимо ввести следующие данные:"
			echo -e "${GREEN}Хост${NOCL} сервера, его ${GREEN}порт, пароль доступа${NOCL} и ${GREEN}метод шифрования${NOCL}"

			echo -e "${BLUE}Пожалуйста, последовательно введите эти данные ниже.${NOCL}"
			print_line

			shadowsocks_read_config
		fi
	# читаем данные и Производим замену в библиотеке ndm основных значения интерфейсов
	} && ndm_interface_change "$(get_ssr_entware_interface)" "shadowsocks"



}
# ------------------------------------------------------------------------------------------
#
#	Чистим таблицу правил iptables для shadowsocks подключений
#
# ------------------------------------------------------------------------------------------
cmd_shadowsocks_iptable_flush() {
	if [ -f /opt/apps/kvas/bin/libs/ndm ]; then
		ready "Удаление правил iptables для shadowsocks завершено"
		ip4_firewall_ssr_prune &>/dev/null
		[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
	fi

}
# ------------------------------------------------------------------------------------------
#
#	Переустанавливаем правила в itables для shadowsocks клиента
#
# ------------------------------------------------------------------------------------------
cmd_shadowsocks_iptable_reset() {

	ready "Переустановка iptables для shadowsocks завершена"
	if [ -f /opt/apps/kvas/bin/libs/ndm ]; then
		local_ip=$(get_router_ip)
		inface=$(get_inface_by_ip "${local_ip}")
		proxy_port=$(get_config_value SSR_DNS_PORT)
		recreate_ip4tables &>/dev/null
		recreate_ssr_rules &>/dev/null

	else
		exit 1
	fi
	[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
}
# ------------------------------------------------------------------------------------------
#
#	Отключаем shadowsocks клиента
#
# ------------------------------------------------------------------------------------------
shadowsocks_off() {
	ready "Интерфейс shadowsocks отключен "
	#	сохраняем файл конфигурации shadowsocks
	/opt/etc/init.d/S22shadowsocks stop &> /dev/null
	[ -f "${SHADOWSOCKS_CONF}" ] || mv -f "${SHADOWSOCKS_CONF}" "${SHADOWSOCKS_CONF}.kvas" &> /dev/null
	rm -f "/opt/etc/ndm/netfilter.d/100-proxy-redirect"
	cmd_shadowsocks_iptable_flush &> /dev/null
	[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
}

# ------------------------------------------------------------------------------------------
#
#	Меняем текущий локальный порт на shadowsocks на новый
#
#	$1 - новый порт
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
cmd_shadowsocks_local_port_change() {
	if has_ssr_enable ; then

		port_new=${1}; cmd=${2:-restart}
		if [ -n "${port_new}" ]	; then

			ready "Замена порта на ${port_new} в shadowsocks завершена"

#			sed -i "s/\(--to-port\).*/\1 ${port_new}/g" "/opt/etc/ndm/netfilter.d/100-proxy-redirect"
			sed -i "s/\(local_port\":\).*/\1 ${port_new}/g" "${SHADOWSOCKS_CONF}"

			set_config_value SSR_DNS_PORT "${port_new}"
			cmd_shadowsocks_iptable_reset &> /dev/null

			[ "${cmd}" = restart ] && /opt/etc/init.d/S22shadowsocks restart &> /dev/null
			[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
		else
			ready "Текущий номер порта shadowsocks соединения:"
			when_ok "$(get_config_value SSR_DNS_PORT)"
		fi
	else
		answer=''
		error "shadowsocks клиент не выбран в настройках"
		read_ynq_timer "Включить его вместо текущего соединения" answer Y 6
		if [ "${answer}" = q ] ; then exit_q; exit 1; fi
		echo "${answer}" | grep -qi y && shadowsocks_on; cmd_shadowsocks_local_port_change "${port_new}"
	fi
}



# ------------------------------------------------------------------------------------------
#
#	Отключаем shadowsocks клиента
#
# ------------------------------------------------------------------------------------------
shadowsocks_on() {

	local_ip=$(get_router_ip)
	inface=$(get_inface_by_ip "${local_ip}")

	#	настройка файла 100-proxy-redirect
	cp "/opt/apps/${APP_NAME}/etc/ndm/netfilter.d/100-proxy-redirect" "/opt/etc/ndm/netfilter.d/100-proxy-redirect"
	chmod +x "/opt/etc/ndm/netfilter.d/100-proxy-redirect"

	ndm_interface_change "$(get_ssr_entware_interface)" "shadowsocks"

	cmd_shadowsocks_iptable_reset  &> /dev/null
	#   настройка S22shadowsocks конфигурации
	if [ -f "${SHADOWSOCKS_CONF}" ] ; then
		if grep -qE '""|@' "${SHADOWSOCKS_CONF}" || grep -qE '127.0.0.1|barfoo!' "${SHADOWSOCKS_CONF}"; then
			print_line
			shadowsocks_read_data
		fi
	else
		if [ -f "${SHADOWSOCKS_CONF_BACKUP}" ] ; then
			if grep -qE '""|@' "${SHADOWSOCKS_CONF_BACKUP}" || grep -qE '127.0.0.1|barfoo!' "${SHADOWSOCKS_CONF_BACKUP}"; then
				error "Архивный файл содержит некорректные данные!"
				print_line
				shadowsocks_read_data
			else
				ready "Используем данные"
				cp "${SHADOWSOCKS_CONF_BACKUP}" "${SHADOWSOCKS_CONF}"
				when_alert "ИЗ АРХИВА"
			fi

		else
			print_line
			shadowsocks_read_data
		fi
	fi

	# меняем данные в файлах shadowsocks
	sed -i 's/ss-local/ss-redir/g' "/opt/etc/init.d/S22shadowsocks"
	#	включаем shadowsocks службу
	print_line
	ready "Запускаем сервис shadowsocks..."
	/opt/etc/init.d/S22shadowsocks restart &> /dev/null
	/opt/etc/init.d/S22shadowsocks status &> /dev/null
	if [ $? = 0 ]; then
		when_ok "УСПЕШНО"
	else
		when_bad "ОШИБКА"
		error "Возникла ошибка при подключении shadowsocks интерфейса!"
		error "Проверьте доступность сервера и настройки клиента!"
		exit 1
	fi
}


# ------------------------------------------------------------------------------------------
#
#	Получаем нумерованный список с именами интерфейсов
#
# ------------------------------------------------------------------------------------------
update_interface_name_list() {

	warning "Производим сканирование интерфейсов!"
	#warning "Это займет время."
	warning "Сохраняйте терпение и спокойствие!"
	print_line

	HOOK_INFACE_FILE=/opt/etc/ndm/$(get_hook_dir)/100-save-inface_entware
	rm -f "${INFACE_NAMES_FILE}"
	touch "${INFACE_NAMES_FILE}"
	# если нет файла по отлавливанию хука
	if ! [ -f "${HOOK_INFACE_FILE}" ]; then
		#	создаем файл
		cat <<EOF >"${HOOK_INFACE_FILE}"
#!/bin/sh
if [ -z "\$(grep "\${id}" "${INFACE_NAMES_FILE}")" ]; then
	echo "\${id}|\${system_name}" >> "${INFACE_NAMES_FILE}"
fi
exit 0
EOF
		chmod +x "${HOOK_INFACE_FILE}"
	fi
	# очищаем файл с именами интерфейсов
	echo "shadowsocks|$(get_ssr_entware_interface)|shadowsocks" > "${INFACE_NAMES_FILE}"
	# обозначаем список типов обрабатываемых VPN интерфейсов
	types_inface='"OpenVPN","Wireguard","IKE","SSTP","PPPOE","L2TP","PPTP"'
#	архивный вариант с выключенными интерфейсами сотовых операторов
#	types_inface='"OpenVPN","Wireguard","IKE","SSTP","PPPOE","L2TP","CdcEthernet","UsbLte"'
	# получаем список ID интерфейсов в наличии на роутере через пробел
	inface_list=$(
		curl -s "${INFACE_REQUEST}" \
			| jq -r '.[] | select([.type]| inside(['"${types_inface}"'])) | select(.defaultgw!=true) | .id' \
			| tr '\n' ' ' | sed 's/[ ]$//g' \
	)
	# проходимся по каждому интерфейсу
	# ВНИМАНИЕ! inface_list - все маленькими буквами!!!
	count=1; delay=4
	list_len=$(echo "${inface_list}" | wc -w)
	for inface_cli in ${inface_list}; do
#		переподключаем текущее соединение
		reset_connection "${inface_cli}" "${delay}"
		# получаем описание интерфейса
		description=$(get_value_interface_field "${inface_cli}" description | sed 's|\/|\\/|g')
		# вставляем описание в файл /opt/etc/inface_equals
		[ -n "${description}" ] && \
			sed -i 's/\('"${inface_cli}"'.*\)/\1|'"${description}"'/' "${INFACE_NAMES_FILE}"
		count=$((count + 1))
	done
	rm -f "${HOOK_INFACE_FILE}"
}
# ------------------------------------------------------------------------------------------
#
#	Получаем нумерованный список с именами интерфейсов для командой строки
#
# ------------------------------------------------------------------------------------------
cmd_scan_interface_list() {
	update_interface_name_list
	warning "Сканирование интерфейсов завершено:";
	print_line
	show_vpn_list
}

# ------------------------------------------------------------------------------------------
#
#	Получаем название интерфейса по номеру в списке в файле INFACE_NAMES_FILE
# 	$1 - номер строки в файле
#	$2 - тип возвращаемых данных
#		cli - id интерфейсов в CLI
#		entware (по умолчанию) - id интерфейсов в entware
#
# ------------------------------------------------------------------------------------------
get_vpn_interface_by_num() {
	number="${1}"
	type_data=${2:-entware}

	if [ "${type_data}" = entware ]; then _type=2; else _type=1; fi
	cat < "${INFACE_NAMES_FILE}" | sed -n "${number}"'p' | cut -d'|' -f"${_type}"
}

# ------------------------------------------------------------------------------------------
#
#	Получаем название текущего интерфейса
# 	$1 - тип интерфейса допустимы entware, cli, cli_desc
#
# ------------------------------------------------------------------------------------------
get_current_vpn_interface() {
	type="${1}"
	if has_ssr_enable; then
		inface='shadowsocks'
	else
		case "${type}" in
			entware) col=2 ;;
			cli) col=1 ;;
			cli_desc) col=3 ;;
			*) col=1 ;;
		esac
		inface_entware=$(get_config_value "INFACE_ENT")
		inface=$(grep "${inface_entware}" "${INFACE_NAMES_FILE}" | cut -d'|' -f"${col}")
	fi
	echo "${inface}"
}

# ------------------------------------------------------------------------------------------
#
#	Переключаем интерфейс клиента
#	$1 - id интерфейса в cli
#
# ------------------------------------------------------------------------------------------
is_vpn_interface_connected() {
	cli_inface="${1}"
	if [ "${cli_inface}" = shadowsocks ] ; then
		/opt/etc/init.d/S22shadowsocks status | grep -q 'alive' &> /dev/null
		if [ $? = 0 ]; then connected="on"; else connected="off"; fi
	else
		if is_interface_online "${cli_inface}"; then connected="on"; else connected="off"; fi
	fi
	echo "${connected}"
}
# ------------------------------------------------------------------------------------------
#
#	Выводим список текущих интерфейсов с номерами по порядку и данными об их доступности
#
# ------------------------------------------------------------------------------------------
show_vpn_list() {

	inface_entware=$(get_current_vpn_interface 'entware')
	num=0;

	while read -r line || [ -n "${line}" ]; do

		num=$((num + 1))
		is_current_vpn=$(echo "${line}" | grep -i "${inface_entware}")
		cli_inface_desc=$(echo "${line}" | cut -d"|" -f3)
		cli_inface=$(echo "${line}" | cut -d"|" -f1)
		ent_inface=$(echo "${line}" | cut -d"|" -f2)
		net_ip=$(get_ip_by_inface "${ent_inface}")
		[ -n "${net_ip}" ] && net_ip=" [${net_ip}]"
		mess="${num}. Интерфейс ${cli_inface_desc}${net_ip}"
		sleep 1
		connected=$(is_vpn_interface_connected "${cli_inface}")

		if [ -n "${inface_entware}" ] && [ -n "${is_current_vpn}" ]; then
			mess="${BLUE}${mess} текущий${NOCL}"
		fi

		ready "${mess}"
		if [ "${connected}" = "on" ]; then when_ok "В СЕТИ"; else when_bad "ОТКЛЮЧЕН"; fi
	done <${INFACE_NAMES_FILE}
}

# ------------------------------------------------------------------------------------------
#
#	Отображаем диалог обновления списка интерфейсов с запросом
#   $1  - ask - делаем запросы на ввод данные ,
#
# ------------------------------------------------------------------------------------------
show_interface_name_list_process(){

#	[ -f "${INFACE_NAMES_FILE}" ] || update_interface_name_list
	answer="${1}"

	if [ -f "${INFACE_NAMES_FILE}" ]; then
		if [ "${answer}" = ask ] ; then
			read_ynq_timer "Обновить список интерфейсов" answer N
			if [ "${answer}" = q ] ; then exit_q; exit 1; fi
			print_line
			if echo "${answer}" | grep -qi y ; then
				update_interface_name_list
			fi
		else
			update_interface_name_list
		fi
	else
		update_interface_name_list
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Переключаем интерфейс клиента
#   $1  - ask - делаем запросы на ввод данные ,
#   	  no - список интерфейсов не обновляем
#
# ------------------------------------------------------------------------------------------
cmd_interface_change() {

	answer="${1}"
	is_install_stage="${2:-no}"

	show_interface_name_list_process "${answer}"

#	Отображаем список текущих интерфейсов с номерами по порядку и данными об их доступности
	select_vpn_interface "${is_install_stage}"

}

switch_vpn_on(){
#	entware интерфейс
	inface_entware=${1}
	cli_inface=${2}
#	Меняем интерфейс в файле ndm
	ndm_interface_change "${inface_entware}" "${cli_inface}"

	if [[ "${inface_entware}" =~ ${SSR_ENTWARE_TEMPL} ]]; then
		vpn_off &> /dev/null
		shadowsocks_backup
		shadowsocks_on
	else
		shadowsocks_off &> /dev/null
		vpn_on "${inface_entware}"
	fi
	[ "${is_install_stage}" = no ] && cmd_kvas_init "no" &> /dev/null

	#------------------------------------------------------
	# Если есть подключенные гостевые сети
	#------------------------------------------------------
	interfaces_list=$(get_guest_inface_list_from_config)
	[ -n "${interfaces_list}" ] && {

		printf '%s\n' "${interfaces_list}" |
        while IFS= read -r iface ; do
#			ready "Подключаем гостевые сети к выбранному VPN подключению..."
			bridge_vpn_access_add "${iface}" #&>/dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
		done
	}

	[ -f /opt/etc/cron.5mins/check_vpn ] || {
		ready "Устанавливаем проверку зависания VPN соединения в cron."
		ln -s /opt/apps/kvas/bin/main/check_vpn /opt/etc/cron.5mins/check_vpn && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
	}


}

# ------------------------------------------------------------------------------------------
#
#	Переключаем интерфейс клиента
#   $1  - ask - делаем запросы на ввод данные ,
#   	  no - список интерфейсов не обновляем
#
# ------------------------------------------------------------------------------------------
select_vpn_interface() {

	is_install_stage="${1:-no}"

	warning "Выберите VPN интерфейс для работы пакета"
	print_line
#	Отображаем список текущих интерфейсов с номерами по порядку и данными об их доступности
	show_vpn_list

	total=$(cat < "${INFACE_NAMES_FILE}" | wc -l)
	while true; do
		print_line
		echo -en "${BLUE}Выберите номер варианта VPN соединения 1 - ${total} | S-скан. | Q-выход:${NOCL} "
		read -r num_vpn_inface
		if [[ "$num_vpn_inface" =~ ^[\-]?[0-9]+$ ]]; then
			print_line
			if [[ "$num_vpn_inface" -ge 1 && "$num_vpn_inface" -le "$total" ]]; then
#			Если выбрали уже интерфейс
	#		Меняем интерфейс в файле ndm
			inface_entware=$(get_vpn_interface_by_num "${num_vpn_inface}")
			cli_inface=$(echo "${INFACE_NAMES_FILE}" | grep "${inface_entware}" | cut -d"|" -f1)
			switch_vpn_on "${inface_entware}" "${cli_inface}"

			else
				error "Число должно быть в пределах от 1 до ${total}"
				continue
			fi
		elif [[ "$num_vpn_inface" =~ ^[Qq]$ ]]; then
			print_line
#			Если нажали на q
			echo -e "${RED}Процедура настройки прервана пользователем!${NOCL}"
			print_line
#			если интернет отключен, то выдаем сообщение
			if curl -s "http://localhost:79/rci/show/interface" | \
				jq -r '.[] | select(.id=="'"$(get_defaultgw_id)"'" and .state=="up" and .link=="up") | .connected' | grep -qv 'yes' ; then

				if cmd_adguardhome_status | grep -q ВКЛЮЧЕН ; then
					/opt/etc/init.d/S56dnsmasq stop  &> /dev/null
				else
					"${ADGUARDHOME_DEMON}" stop &> /dev/null
				fi
				cli="$(get_router_host)/a"
				echo -e "${RED}К сожалению, у Вас пропал интернет. ${NOCL}"
				echo -e "${RED}Проверьте основное подключение к провайдеру. ${NOCL}"
				print_line
				echo "Если ничего не помогает, то для восстановления подключения"
				echo -e "необходимо зайти в админ панель роутера по адресу: ${GREEN}${cli}${NOCL}"
				echo "и выполнить последовательно три следующих команды: "
				print_line
				echo -e "1. ${GREEN}no opkg dns-override ${NOCL}       - вновь подключаем DNS провайдера,"
				echo -e "2. ${GREEN}system configuration save ${NOCL}  - сохраняем изменения,"
				echo -e "3. ${GREEN}system reboot ${NOCL}              - перегружаем роутер."
				print_line
				exit 1
			fi
			exit
		elif [[ "$num_vpn_inface" =~ ^[Ss]$ ]]; then
			print_line
			cmd_interface_change "no" "${is_install_stage}"
		else
			error "Введите цифру 1-${total} или S - сканирование, Q - выход."
			continue
		fi
		break
	done

}

# ------------------------------------------------------------------------------------------
#
#	Обновляем маршруты и таблицы ipset...
#
# ------------------------------------------------------------------------------------------
cmd_update_list() {
	ready "Обновляем маршруты и таблицы ipset..."
	"${UPDATE_BIN_FILE}" miss_ads &> /dev/null
	[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
}
# ------------------------------------------------------------------------------------------
#
#	Меняем текущий порт dnscrypt_proxy2 на новый
#
#	$1 - новый номер порта
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
dns_crypt_port_change() {

	port_new=${1}; cmd=${2:-restart}
	ready "Замена локального порта на ${port_new} в dnscrypt_proxy2 завершена"

	set_config_value DNS_CRYPT_PORT "${port_new}"
	sed -i "s/\(^listen_addresses.=.\).*$/\1['[::]:${port_new}']/g" "${DNSCRYPT_CONFIG}" &> /dev/null
	sed -i "s/\(@.*\)\(:[0-9]\{2,6\}\)/\1:${port_new} /g" '/opt/apps/kvas/bin/main/ipset' &> /dev/null

	server_crypt_0="echo \"server=\/:.*\${host}:\/${LOCALHOST_IP}#${port_new}\" >> \/opt\/etc\/kvas.dnsmasq"
	server_crypt_1="echo \"server=\/\${host}\/${LOCALHOST_IP}#${port_new}\" >> \/opt\/etc\/kvas.dnsmasq"
	sed -i '/server/d' '/opt/apps/kvas/bin/main/dnsmasq' &> /dev/null
	sed -i "s/\(echo \"ipset=\/:.*\)/\1\n\t${server_crypt_0}/" '/opt/apps/kvas/bin/main/dnsmasq' &> /dev/null
	sed -i "s/\(echo \"ipset=\/\$.*\)/\1\n\t${server_crypt_1}/" '/opt/apps/kvas/bin/main/dnsmasq' &> /dev/null

	if [ "${cmd}" = restart ]; then
		cmd_dnsmasq_dns_change "${LOCALHOST_IP}#${port_new}" restart &> /dev/null
		if ! [ -f /opt/etc/init.d/S09dnscrypt-proxy2 ]; then
			if [ -f "${KVAS_BACKUP_PATH}/S09dnscrypt-proxy2" ]; then
				cp "${KVAS_BACKUP_PATH}/S09dnscrypt-proxy2" /opt/etc/init.d/S09dnscrypt-proxy2
			else
				error "Нарушена работа пакета, файл /opt/etc/init.d/S09dnscrypt-proxy2 отсутствует"
				exit 1
			fi
		fi
		/opt/etc/init.d/S09dnscrypt-proxy2 restart &> /dev/null
	else
		cmd_dnsmasq_dns_change "${LOCALHOST_IP}#${port_new}" &> /dev/null
	fi

	[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}


# ------------------------------------------------------------------------------------------
#
# 	Пересоздаем таблицу ipset для dnsmasq и перезапускаем сервис
# 	В том числе и обрабатываем dns_crypt в случае, если он запущен
#
# ------------------------------------------------------------------------------------------
refresh_dnsmasq_ipset_table(){

		ready "${prefix}Заполняем dnsmasq таблицу данными из списка разблокировки."
		if /opt/apps/kvas/bin/main/dnsmasq  ; then #&>/dev/null
			when_ok "УСПЕШНО"
		else
			if /opt/apps/kvas/bin/main/dnsmasq  ; then
				when_ok "УСПЕШНО"
			else
				when_bad "ОШИБКА"
			fi
		fi
#		ready "${prefix}Перезапускаем сервис dnsmasq"
#		/opt/etc/init.d/S56dnsmasq restart &>/dev/null
#		[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
#
#		if get_dns_crypt_status | grep -q on ; then
#			ready "${prefix}Перезапускаем сервис dns_crypt"
#			dns_crypt_install '' &>/dev/null
#			[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
#		fi
}


# ------------------------------------------------------------------------------------------
#
#	 Статус dnscrypt_proxy2
#	 on - включен
#	 off - выключен
#
# ------------------------------------------------------------------------------------------
get_dns_crypt_status() {
	crypt_port=$(get_config_value DNS_CRYPT_PORT)
	if [ -f '/opt/sbin/dnscrypt-proxy' ] &&
		cat < '/opt/apps/kvas/bin/main/ipset' | grep '@' | grep -q "${crypt_port}" &&
		cat < '/opt/apps/kvas/bin/main/dnsmasq' | grep -q 'server' &&
		netstat -tulnp 2> /dev/null | grep -q dnscrypt; then

		echo on
	else
		echo off
	fi

}
# ------------------------------------------------------------------------------------------
#
#	 Устанавливаем с нуля dnscrypt_proxy2
#
# ------------------------------------------------------------------------------------------
dns_crypt_install() {
	is_install_stage="${1}"
#	В случае наличия архива файла запуска сервиса dnscrypt_proxy2
	if [ -f /opt/etc/init.d/K09dnscrypt-proxy2 ]; then
		#warning "Обнаружен архив файла S09dnscrypt-proxy2."
		ready "Восстанавливаем S09dnscrypt-proxy2 из архива..."
#		реанимируем его из архива
		cp /opt/etc/init.d/K09dnscrypt-proxy2 /opt/etc/init.d/S09dnscrypt-proxy2 1> /dev/null 2> "${ERROR_LOG_FILE}"
		ready_status "${?}" "Ошибка при восстановлении S09dnscrypt-proxy2 из архива"
	else
		# Если запуск функции был не при установке пакета Квас
			if [ -z "${is_install_stage}" ]; then
		#		при его отсутствии - устанавливаем пакет
				if ! [ -f /opt/etc/init.d/S09dnscrypt-proxy2 ]; then
					ready "Устанавливаем пакет dnscrypt-proxy2..."
					opkg update &> /dev/null
					opkg remove dnscrypt-proxy2 --force-depends 1> /dev/null 2> "${ERROR_LOG_FILE}"
					opkg install dnscrypt-proxy2 --force-maintainer 1> /dev/null 2> "${ERROR_LOG_FILE}"
					when_error "${?}" "Ошибка при установке пакета dnsmasq"
				fi
			else
				if ! [ -f /opt/etc/init.d/S09dnscrypt-proxy2 ]; then
	#				Если вызвана функция из postinst
					error "Пакет dnscrypt-proxy2 был установлен с ошибками или поврежден!"
					error "Файл запуска пакета /opt/etc/init.d/S09dnscrypt-proxy2 отсутствует!"
					warning "Удалите Квас и затем переустановите пакет dnscrypt-proxy2"
					exit 1
				fi
			fi


	fi
#	Если dnscrypt_proxy2 запущен, то останавливаем его,
#	так как необходимо его предварительно настроить
	if /opt/etc/init.d/S09dnscrypt-proxy2 status | grep -q alive ; then
		ready "Останавливаем службу dnscrypt-proxy2..."
		/opt/etc/init.d/S09dnscrypt-proxy2 stop 1> /dev/null 2> "${ERROR_LOG_FILE}"
		ready_status "${?}" "Проблема при остановке службы dnscrypt-proxy2"
	fi

#	архивируем предыдущие настройки
	if [ -f '/opt/etc/dnscrypt-proxy.toml' ]; then
		#warning "Файл конфигурации dnscrypt-proxy2 сохраняем"
		cp /opt/etc/dnscrypt-proxy.toml ${KVAS_BACKUP_PATH}/dnscrypt-proxy.toml
		#warning "под именем ${KVAS_BACKUP_PATH}/dnscrypt-proxy.toml"
	elif [ -f "${KVAS_BACKUP_PATH}/dnscrypt-proxy.toml" ]; then
		#warning "Обнаружен файл конфигурации dnscrypt-proxy2 "
		cp "${KVAS_BACKUP_PATH}/dnscrypt-proxy.toml" /opt/etc/dnscrypt-proxy.toml
		#warning "Восстанавливаем предыдущие настройки."
	fi

#	Настраиваем сервис
	ready "Настраиваем dnscrypt-proxy2..."
	cmd_dns_crypt_on 1> /dev/null 2> "${ERROR_LOG_FILE}"
	ready_status "${?}" "Проблема при активации шифрования DNS трафика"
}
# ------------------------------------------------------------------------------------------
#
#	 Включаем работу блока шифрования dns при помощи dnscrypt_proxy2
#
# ------------------------------------------------------------------------------------------
cmd_dns_crypt_on() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		crypt_port=$(get_config_value DNS_CRYPT_PORT)
		if [ "$(get_dns_crypt_status)" = on ]; then
			ready "Шифрование DNS уже";	when_ok "ПОДКЛЮЧЕНО"
		else
			dns_crypt_port=$(get_config_value DNS_CRYPT_PORT)
			dns_cache_enabled=$(get_config_value DNS_CACHE_ENABLED)
			ready "Шифрование DNS"
			{
#				sed -i "s/\(^cache.=.\).*$/\1${dns_cache_enabled}/g" '/opt/etc/dnscrypt-proxy.toml'
#				оставляем кеш выключенным за счет работы механизма кеширвоания dnsmasq
				sed -i "s/\(^cache.=.\).*$/\1false/g" '/opt/etc/dnscrypt-proxy.toml'
				sed -i "s/\(^require_dnssec.=.\).*$/\1true/g" '/opt/etc/dnscrypt-proxy.toml'
				sed -i "s/\(^cache_min_ttl.=.\).*$/\10/g" '/opt/etc/dnscrypt-proxy.toml'

				sed -i "/proxy-dnssec/d" /opt/etc/dnsmasq.conf
				echo "proxy-dnssec" >> /opt/etc/dnsmasq.conf
				dns_crypt_port_change "${dns_crypt_port}" restart

			} 1> /dev/null 2> "${ERROR_LOG_FILE}"
			ready_status "${?}" "Произошла непредвиденная ошибка." "ПОДКЛЮЧЕНО"
		fi
	}
}
# ------------------------------------------------------------------------------------------
#
#	 ВЫключаем работу блока шифрования dns при помощи dnscrypt_proxy2
#
# ------------------------------------------------------------------------------------------
cmd_dns_crypt_off() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		ready "Шифрование DNS"
		{
			crypt_port=$(get_config_value DNS_CRYPT_PORT)
			static_dns=$(get_config_value DNS_STATIC_1)
			sed -i "s/\(@.*\)\(:[0-9]\{2,6\}\)/@localhost/g" '/opt/apps/kvas/bin/main/ipset'
			sed -i "/proxy-dnssec/d" /opt/etc/dnsmasq.conf
			sed -i "s/\(^server=\)${LOCALHOST_IP}#${crypt_port}/\1${static_dns}/" /opt/etc/dnsmasq.conf
			sed -i '/server/d' '/opt/apps/kvas/bin/main/dnsmasq'

			rm "${DNSMASQ_IPSET_HOSTS}"
			_dns=$(cat < "${DNSMASQ_CONFIG}" | sed -n 's/^server=\(.*\)$/\1/p')
			set_config_value DNS_DEFAULT "${_dns}#${MAIN_DNS_PORT}"
			set_config_value DNS_CRYPT_PORT "${crypt_port}"

			/opt/etc/init.d/S09dnscrypt-proxy2 stop
			cmd_kvas_init "no"

		} 1> /dev/null 2> "${ERROR_LOG_FILE}"
		ready_status "${?}" "Произошла непредвиденная ошибка." "ОТКЛЮЧЕНО"
	}
}
# ------------------------------------------------------------------------------------------
#
#	 Выводим статус блока шифрования dns при помощи dnscrypt_proxy2
#
# ------------------------------------------------------------------------------------------
cmd_dns_crypt_status_show() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		ready "Шифрование DNS"
		if [ "$(get_dns_crypt_status)" = on ]; then
			when_ok "ПОДКЛЮЧЕНО"
		else
			when_bad "ОТКЛЮЧЕНО"
		fi
	}

}

iptables_reset(){
	#	Производим переустановку правил в iptable таблице
	if has_ssr_enable; then
		cmd_shadowsocks_iptable_reset
		export type=iptables; export table=mangle && /opt/etc/ndm/netfilter.d/100-proxy-redirect &> /dev/null
	else
		cmd_vpn_iptable_reset
	fi


}


# ------------------------------------------------------------------------------------------
#
#	Тестируем хост на доступность
#	$1 - доменное имя
#	$2 - команда для возврата:
#		ip - возвращает ip вместо 1
#
# ------------------------------------------------------------------------------------------
test_host() {

	ret=0
	if echo "${1}" | grep -q '\.' ; then
		dns=$(get_config_value DNS_DEFAULT )
		ips="$(get_iplist_from_domain "${1}" "${dns}" 2> /dev/null)"
		if [ -z "${ips}" ]; then
			dns=$(get_config_value DNS_STATIC_1)
			ips=$(get_iplist_from_domain "${1}" "${dns}" 2> /dev/null)

			if [ -z "${ips}" ]; then
				dns=$(get_config_value DNS_STATIC_2);
				ips=$(get_iplist_from_domain "${1}" "${dns}" 2> /dev/null)
				[ -n "${ips}" ] && set_config_value DNS_DEFAULT "${dns}"
			else
				set_config_value DNS_DEFAULT "${dns}"
			fi
		fi
		if [ -n "${2}" ] && [ "${2}" = ip ]; then
			ret=${ips}
		else
			if [ -n "$( echo "${ips}" | head -1 2> /dev/null )" ]; then ret=1; fi
		fi
	fi
	echo "${ret}"

}

add_host_to_adguard(){
	clear_host="${1}"
	#   AdGuardHome обработка
	echo "${_host}" >> "${UNBLOCK_LIST_FILE}"
	[ -f "${ADGUARD_IPSET_FILE}" ] && cat < "${ADGUARD_IPSET_FILE}" | grep -q "${clear_host}" \
	 		|| echo "${clear_host}/unblock" >> "${ADGUARD_IPSET_FILE}"
	if echo "${host}" | grep -q '\*' ; then
  		echo "ipset=/:.*${clear_host}:/unblock" >> "${DNSMASQ_IPSET_HOSTS}"
  	else
    	echo "ipset=/${clear_host}/unblock" >> "${DNSMASQ_IPSET_HOSTS}"
  	fi
}

add_host_to_ipset(){
	clear_host="${1}"
	. /opt/apps/kvas/bin/libs/ipset
	#
#	# если строка начинается с IP, то проводим обработку по IP
		add_host_by_iplist_to_ipset "${clear_host}" &> /dev/null
}

# ------------------------------------------------------------------------------------------
#
# 	Добавляем один хост
# 	$1 - имя домена
# 	$2 - делаем ли сброс таблиц или нет (нужно отключать при импорте множества доемнных имен)
#	$3 - если  параметр был задан как 'yes|y|wild' то, добавляем * без вопросов
#
# ------------------------------------------------------------------------------------------
host_add() {
	if echo "${1}" | grep -qE "${IP_FILTER}|${NET_FILTER}" ; then
		clear_host="${1}"
	else
		clear_host=$(echo "${1}" | sed 's/\*//;' | sed -n -E 's|^(http(s)?://)?([^/]+).*|\3|p')
	fi
	reset="${2}"
	wild="${3}"
#	в режиме импорта хост не трогаем - оставляем как есть
	[ "${wild}" = import ] || _host="${clear_host}"

	if echo "${wild}" | grep -qiE 'import|no|n' ; then
#		в режиме импорта задавать вопросы не нужно - добавляем хост как есть.
		answer=n
	else
#		Если адрес или сеть, то пропускаем вопрос
		if echo "${clear_host}" | grep -qE "${IP_FILTER}|${NET_FILTER}" ; then
			answer=n
		else
#			Если третий параметр был задан как 'yes|y|wild' то, добавляем * без вопросов
			if echo "${wild}" | grep -qiE 'yes|y|wild' ; then
				answer=y
			else
				answer='';
#				Задаем вопрос о необходимости поддержки режима wildcard и ждем 6 сек на ответ
# 				если ответа не поступило, то по умолчанию ответ 'Y'
				read_ynq_timer "Добавить хост с поддоменами wildcard [Y] или нет [N]?" answer Y 6
				if [ "${answer}" = q ] ; then exit_q; exit 1; fi
				print_line
			fi
		fi
	fi

#	Проверяем на необходимость поддержки wildcard
	if echo "${answer}" | grep -qiE 'y|yes' ; then
		_host="*${clear_host}"
	fi

	ready "Добавляем ${YELLOW}${_host}${NOCL} в список разблокировки..."
	echo "${_host}" >> "${UNBLOCK_LIST_FILE}"

#	если включен блокировщик рекламы
	if cmd_ads_status | grep -q ВКЛЮЧЕН ; then
		ads_list_hosts_update &> /dev/null
	fi

	[ "${reset}" = 'yes' ] && cmd_kvas_init  &> /dev/null

	cmd_adguardhome_status | grep -q ВКЛЮЧЕН && add_host_to_adguard "${clear_host}" &> /dev/null
	add_host_to_ipset "${clear_host}" &> /dev/null

	[ $? = 0 ] && when_ok "ДОБАВЛЕН" || when_bad "НЕ ДОБАВЛЕН"



}
# ------------------------------------------------------------------------------------------
#
#	Добавляем в белый список одно доменное имя, точнее список его IP адресов
#	$1 - доменное имя, для которого необходимо получить IP
# 	$2 - делаем ли сброс таблиц или нет (нужно отключать при импорте множества доемнных имен)
# 	$3 - режим тестирования домена, если не пусто, проводим тестирование,
# 		 если равно, test то выдаем данные о добавлении для команды import
#
# ------------------------------------------------------------------------------------------
cmd_add_one_host() {

	host=$(echo "${1}" | sed 's|http[s]\{,1\}://||;')
	reset="${2:-yes}"
	wild="${3}"

	# Выходим из функции при отуствии интернет-соединения или VPN
	exit_when_no_internet_or_vpn_connected || exit 1 

	# Проверяем есть ли в введенной строке имя метки или нет
	tag_name=$("${@}" | grep -oP '(?<=-tag )\S+')

	if [ -n "${tag_name}" ] ; then
		# Помечаем доменное имя тегом 
		cmd_add_domain_to_tag_list "${tag_name}" "${host}"
		# Если  помимо этого домена существует еще доменные с одноименным тегом
		# то делаем запрос на их доавление.
		local _tmpfile=$(mktemp)
		_get_same_tag_domains_missing_in_protection_list "${host}" > "${_tmpfile}"
		# Проверяем есть ли в этом списке домены
		[ -s "${_tmpfile}" ] && {
			# Если есть, то спрашивем добавить ли их
			read_ynq "Найдены доменные имена с тегом '${tag_name}',\nкоторых пока нет в списке защищенных доменнов.\nДобавить их в список?" answer
			[[ "$answer" =~ [qn] ]] && return 1
			if [[ "$answer" =~ [y] ]] ; then
				print_line
				cmd_import_hosts "${_tmpfile}"
			fi
			rm -f "${_tmpfile}"
			return 0
		}
	fi


	clear_host=$(echo "${host}" | sed 's/\*//')
	ip_filter='[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
	#	формальная проверка на наличие точки в имени домена
	if echo "${host}" | grep -q '\.' ; then
		# если точка в имени домена есть, то проверяем на корректность IP
		if echo "${clear_host}" | grep -qE "${ip_filter}*" ; then

			# если точка в имени домена есть, то проверяем на корректность IP
			if echo "${clear_host}" | grep -qE "^${ip_filter}/[0-9]{1,2}$|^${ip_filter}$|^${ip_filter}-${ip_filter}$"; then
				# если включен режим импорта
				if [ "${wild}" = import ]; then
					host_add "${host}" "${reset}" "${wild}" | grep -q "ДОБАВЛЕН" && echo +
				else
					host_add "${host}" "${reset}" "${wild}"
				fi
			else
				if [ "${wild}" = import ]; then
					echo 2
				else
					error "Введенный IP адрес или диапазон IP-адресов имеет некорректный формат." nl
				fi
			fi
		else
			# проверка на наличие домена в списке защиты доменов
			if cat < "${UNBLOCK_LIST_FILE}" | grep -qE "^${clear_host}"; then
				[ "${wild}" = import ] || warning "Такой домен уже есть в списке разблокировки!"
				if [ "${clear_host}" != "${host}" ] ; then
					warning "Производим замену ${clear_host} на ${host}"
					print_line
					sed -i "/^${clear_host}$/d" "${UNBLOCK_LIST_FILE}"

					if [ "${wild}" = import ]; then
						host_add "${host}" "${reset}" "${wild}" | grep -q "ДОБАВЛЕН" && echo 1
					else
						host_add "${host}" "${reset}" "${wild}"
					fi
				else
					[ "${wild}" = import ] && echo -
				fi

			else

				if [ "${wild}" = import ]; then
					host_add "${host}" "${reset}" "${wild}" | grep -q "ДОБАВЛЕН" && echo +
				else
					host_add "${host}" "${reset}" "${wild}"
				fi
			fi
		fi
	else
		if [ "${wild}" = import ]; then
			echo 2
		else
			error "Некорректно указано имя домена - ${1}." no_nln
		fi
	fi
}


# ------------------------------------------------------------------------------------------
#
#	Удаляем из белого списка одно доменное имя, точнее список его IP адресов
#	$1 - доменное имя для удаления
#
# ------------------------------------------------------------------------------------------
cmd_del_one_host() {

	# Выходим из функции при отуствии интернет-соединения или VPN
	exit_when_no_internet_or_vpn_connected || exit 1 

	host_="${1}"
	if cat < "${UNBLOCK_LIST_FILE}" | grep -qe "${host_}$" ; then
		ready "Удаляем ${YELLOW}${host_}${NOCL} из списка защищенных..."
		sed -i "/${host_////\\/}/d" "${UNBLOCK_LIST_FILE}"

		cmd_adguardhome_status | grep -q ВКЛЮЧЕН && sed -i "/${host_////\\/}/d" "${ADGUARD_IPSET_FILE}"
		cmd_kvas_init  &> /dev/null
#		cmd_kvas_init  "refresh"  &> /dev/null
		[ $? = 0 ] && when_ok "УДАЛЕН" || when_bad "НЕ УДАЛЕН"
		#	если включен блокировщик рекламы
		if cmd_ads_status | grep -q ВКЛЮЧЕН ; then
			ready "Удаляем ${YELLOW}${host_}${NOCL} из списка блокировки рекламы..."
			/opt/apps/kvas/bin/main/adblock &> /dev/null
			[ $? = 0 ] && when_ok "УДАЛЕН" || when_bad "НЕ УДАЛЕН"
		fi
		cmd_vpn_iptable_reset &> /dev/null

	else
		error "Такая запись отсутствует в списке защищенных!" no_nln
	fi
}


# ------------------------------------------------------------------------------------------
#
#	Удаляем из белого списка множество доменных имен
#	$1 - список доменных имен для удаления
#
# ------------------------------------------------------------------------------------------
del_multy_hosts() {
	list_to_del="$1"

	if [ -z "${list_to_del}" ]; then
		error "Список пуст!" 
		return 1
	else
		for host_ in ${list_to_del}; do
			ready "Удаляем ${YELLOW}${host_}${NOCL} из списка защищенных..."
			if cat < "${UNBLOCK_LIST_FILE}" | grep -qe "${host_}$" ; then
				
				sed -i "/${host_////\\/}/d" "${UNBLOCK_LIST_FILE}"
				cmd_adguardhome_status | grep -q ВКЛЮЧЕН && sed -i "/${host_////\\/}/d" "${ADGUARD_IPSET_FILE}"
				[ $? = 0 ] && when_ok "УДАЛЕН" || when_bad "НЕ УДАЛЕН"
			else 
				when_alert "НЕТ В СПИСКЕ"
			fi
		done
		#	если включен блокировщик рекламы
		if cmd_ads_status | grep -q ВКЛЮЧЕН ; then
			ready "Удаляем имена выше из списка блокировки рекламы"
			/opt/apps/kvas/bin/main/adblock &> /dev/null
			[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
		fi
		ready "Перегружаем все правила конфигурации iptables и ipset"
		cmd_kvas_init  &> /dev/null && cmd_vpn_iptable_reset &> /dev/null
		[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
	fi

}
# ------------------------------------------------------------------------------------------
#
#	Очищаем полностью белый список
#
# ------------------------------------------------------------------------------------------
cmd_clear_list() {

	if [ -f "${UNBLOCK_LIST_FILE}" ]; then
		if [ "$(rec_in_file "${UNBLOCK_LIST_FILE}")" = '0' ]; then
			error "Список разблокировки не содержит записей!"
		else
			while true; do
				ready "Список разблокировки будет полностью очищен. Уверены?" && read -r yn
				case ${yn} in
				[Yy]*)
					# Выходим из функции при отуствии интернет-соединения или VPN
					exit_when_no_internet_or_vpn_connected || exit 1 
					
					print_line
					ready "Очищаем список разблокировки ..."
					mv -f "${UNBLOCK_LIST_FILE}" "${KVAS_LIST_FILE_BACKUP}"
					rm -f "${ADGUARD_IPSET_FILE}"
					touch "${UNBLOCK_LIST_FILE}"
					cmd_kvas_init  "update" &> /dev/null
					[ $? = 0 ] && when_ok "ОЧИЩЕН" || when_bad "ОШИБКА"
					print_line
					warning "Предыдущий список разблокировки был сохранен в файл ${KVAS_LIST_FILE_BACKUP}"
					break
					;;
				[Nn]*)
					break
					;;
				*)
					please_repeat
					;;
				esac
			done
		fi
	else
		error "Списочный файл не существует!"
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Считаем число строк/записей в переданной переменной
#
# ------------------------------------------------------------------------------------------
rec_in_var() {
	echo -e "${1}" | sed '/^$/d' | wc -l
}


# ------------------------------------------------------------------------------------------
#
#	Импортируем (вносим) список доменов в "белый список"
#
#	$1 - имя файла со списком доменных имен, допускается использование # для комментариев
#		 одно имя - одна строка в списочном файле
#
# ------------------------------------------------------------------------------------------

cmd_import_hosts() {

	# Выходим из функции при отуствии интернет-соединения или VPN
	exit_when_no_internet_or_vpn_connected || exit 1 

	host_list="${1}"
	if [ -z "${host_list}" ]; then
		error "Не задано имя файла для импорта."
		error "Укажите его вторым аргументом при запуске!"
	else
		if ! [ -f "${host_list}" ]; then
			error "Списочный файл ${host_list} не существует."
			error "Проверьте верность написания пути и его имени."
		else
			ready "Импортируем хосты в список защищаемых доменов и обновляем маршруты..."
			clear_file_content "${host_list}"

			clear_file_content "${UNBLOCK_LIST_FILE}"

			hosts_to_add_ubl=''
			hosts_repeated_ubl=''
			hosts_not_added=''
			hosts_errors=''

			while read -r line || [ -n "${line}" ]; do
				# удаляем из строки комментарии - все что встречается после символа # и сам символ
				host=$(echo "${line}" | sed 's/#.*$//g' | tr -s ' ')
				#  пропускаем пустые строки и строки с комментариями
				[ -z "${host}" ] && continue
				#  пропускаем строки с комментариями
				[ "${host:0:1}" = "#" ] && continue

				case "$(cmd_add_one_host "${host}" "no" "import")" in
				0) hosts_not_added="${hosts_not_added}${host}\n" ;;
				1) hosts_repeated_bl="${hosts_repeated_bl}${host}\n" ;;
				+) hosts_to_add_ubl="${hosts_to_add_ubl}${host}\n" ;;
				2) hosts_errors="${hosts_errors}${host}\n";;
				*) ;;
				esac
			done < "${host_list}"

			#     добавляем хосты в файл списочный
			_hosts_to_add_ubl=$(echo -e "${hosts_to_add_ubl}" | sed '/^$/d; /^[-+.]/!s/\(.*\)/\1/')
			echo -e "${_hosts_to_add_ubl}" >> "${UNBLOCK_LIST_FILE}"

			#	если включен блокировщик рекламы
			if cmd_ads_status | grep -q ВКЛЮЧЕН ; then
				ads_list_hosts_update &> /dev/null
			fi

			cmd_kvas_init  "update" &> /dev/null

			[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

			num_not_added=$(rec_in_var "${hosts_not_added}")
			num_repeated_ubl=$(rec_in_var "${hosts_repeated_ubl}")
			num_to_add_ubl=$(rec_in_var "${hosts_to_add_ubl}")
			num_errors=$(rec_in_var "${hosts_errors}")

			num_errors=$((num_not_added + num_repeated_ubl + num_errors))
			tab="    "
			print_line
			if [ "${num_to_add_ubl}" -eq 0 ]; then
				warning "Новых записей добавлено не было!"
			else
				warning "В список разблокировки было добавлено ${YELLOW}${num_to_add_ubl}${GREEN} новых домена/ов:"
				print_line
				if [ "${num_to_add_ubl}" -gt 0 ]; then
					warning "${tab}Список добавленных доменов:"
					print_line
					echo -e "${hosts_to_add_ubl}" | sed 's/^$//; /^[-]/!s/\(.*\)/'"${tab}${tab}"'\1/g'
				fi
			fi
			if [ "${num_errors}" -gt 0 ]; then
				echo
				error "В ходе импорта возникли ошибки ${YELLOW}${num_errors}${RED} шт.:"
				print_line
				if [ "${num_not_added}" -gt 0 ]; then
					error "${tab}Проблем в написании или недоступности доменов выявлено ${YELLOW}${num_not_added}${RED} шт."
					print_line
					echo -e "${hosts_not_added}" | sed 's/^$/'"$(print_line)"'/; /^[-]/!s/\(.*\)/'"${tab}${tab}"'\1/g'
				fi
				if [ "${num_repeated_ubl}" -gt 0 ]; then
					error "${tab}Домены ниже уже присутствуют в списке разблокировки [${YELLOW}${num_repeated_ubl}${RED} шт.]"
					print_line
					echo -e "${hosts_repeated_ubl}" | sed 's/^$/'"$(print_line)"'/; /^[-]/!s/\(.*\)/'"${tab}${tab}"'\1/g'
				fi
			fi
		fi
	fi
}



# ------------------------------------------------------------------------------------------
#
#	Экспортируем (сохраняем) список доменов в другой файл
#	$1 - имя файла архива
#
# ------------------------------------------------------------------------------------------
cmd_export_hosts() {
	HOSTS_LIST=$(cat < "${UNBLOCK_LIST_FILE}" | sed 's/\(^.*\)#.*$/\1/g' | grep -v '#' | tr -s '\n')
	backup_name=${1}
	if [ -z "${backup_name}" ]; then
		error "Так как не задано имя файла для экспорта, то"
		error "Сохраняем архив в файл ${KVAS_LIST_FILE_BACKUP}"
	else
		mkdir -p "$(dirname "${backup_name}")" && touch "${backup_name}" &> /dev/null
	fi
	ready "Сохраняем записи в файл ${YELLOW}${backup_name}${GREEN}..."
	echo "${HOSTS_LIST}" > "${backup_name}"
	[ $? = 0 ] && when_ok "СОХРАНЕНЫ" || when_bad "ОШИБКА"
}




# -------------------------------------------------------------------------------------------
#
#   Функция для добавления доменов в список для защиты
#
# ------------------------------------------------------------------------------------------
add_tag_section_to_protect_list() {

    local section="$1"
    local tag_selected answer
    tag_select "добавления" tag_selected
    [ -n "${tag_selected}" ] && {
        print_line
        echo -e "В защищенный список будут добавлены следующие домены:"
        print_line
        local domains=$(get_tag_domain_list "${tag_selected}")
        echo -e "${domains}" | sed '$d' | sort -u  | sed = | sed 'N;s/\n/. /g'
        print_line
        read_ynq "Добавляем?" answer
        if [[ "$answer" =~ [qQ] ]] ; then
            return 0 
        elif [ "${answer}" = y ]; then
            print_line
            local TMPFILE=$(mktemp)
            echo "${domains}" | sed '$d' > "${TMPFILE}"
            cmd_import_hosts "${TMPFILE}"
            rm "${TMPFILE}"
        fi
    }
}


# -------------------------------------------------------------------------------------------
#
#   Функция для удаления доменов из списка защиты
#
# ------------------------------------------------------------------------------------------
del_tag_section_to_protect_list() {

    local section="$1"
    local tag_selected answer
    tag_select "удаления" tag_selected
    [ -n "${tag_selected}" ] && {
        print_line
        echo -e "Из защищенного списка будут удалены следующие домены:"
        print_line
        local domains=$(get_tag_domain_list "${tag_selected}")
        echo -e "${domains}" | sed '$d' | sort -u  | sed = | sed 'N;s/\n/. /g'
        print_line
        read_ynq "Удаляем?" answer
        if [[ "$answer" =~ [qQ] ]] ; then
            return 0 
        elif [ "${answer}" = y ]; then
            print_line
            del_multy_hosts "${domains}"
        fi
    }
}



# ------------------------------------------------------------------------------------------
#
#	Отображаем БС
#
# ------------------------------------------------------------------------------------------
print_host_list(){
	warning "Список разблокировки содержит ${YELLOW}${num_plus}${GREEN} записей:"
	print_line
	clear_content "${UNBLOCK_LIST_FILE}"
}

cmd_show_list() {

	if [ -f "${UNBLOCK_LIST_FILE}" ]; then
		num_plus=$(rec_in_file "${UNBLOCK_LIST_FILE}")
		if [ "${num_plus}" -eq 0 ]; then
			echo -e "${RED}Список разблокировки пуст!${NOCL}"
#			Если список хостов пуст, то проверяем есть ли архивная копия
			if [ -f "${KVAS_LIST_FILE_BACKUP}" ] ; then
				print_line
				warning "Обнаружена архивная копия списка разблокировки!"
				answer=''; read_ynq_timer "Восстановить данные из архива или нет [Y/N]?" answer Y 10
				if [ "${answer}" = q ] ; then exit_q; exit 1; fi
				if echo "${answer}" | grep -qi y ; then
					cp "${KVAS_LIST_FILE_BACKUP}" "${UNBLOCK_LIST_FILE}"
					warning "Список разблокировки восстановлен из архивной копии."
					print_line
					print_host_list
				else
					print_line
					warning "Пожалуйста, добавьте данные в список при помощи 'kvas add имя_домена'"
				fi
			else
				print_line
				warning "Пожалуйста, добавьте в него данные при помощи 'kvas add имя_домена'"
			fi
		else
			print_host_list
		fi
	else
#		Если список хостов не существует, то проверяем, есть ли архивная копия
		if [ -f "${KVAS_LIST_FILE_BACKUP}" ] ; then
			warning "Обнаружена архивная копия списка разблокировки!"
				answer=''; read_ynq_timer "Восстановить данные из архива (Y) или нет (N)?" answer Y 10
				if [ "${answer}" = q ] ; then exit_q; exit 1; fi
				if echo "${answer}" | grep -qi y ; then
					cp "${KVAS_LIST_FILE_BACKUP}" "${UNBLOCK_LIST_FILE}"
					warning "Список разблокировки восстановлен из архивной копии."
					print_line
					print_host_list
				fi
		else
			error "Списка разблокировки не существует."
			warning "Пожалуйста, добавьте в него данные при помощи 'kvas add имя_домена'"
		fi
	fi
}
