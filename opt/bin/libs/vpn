#!/bin/sh
. /opt/apps/kvas/bin/libs/debug
. /opt/apps/kvas/bin/libs/ndm
. /opt/apps/kvas/bin/libs/adblock
. /opt/apps/kvas/bin/libs/main
# ------------------------------------------------------------------------------------------
#
# 	Добавляет хосты в белый список, доступ к сайтам которого
#   осуществляется через Shadowsocks
#
#	Разработчик: mail@zeleza.ru
#	Дата: 21/05/2022
#	Лицензия: Apache License 2.0
#	75 функций (на 23/07/2022)
#	
# ------------------------------------------------------------------------------------------
#	Основные переменные для работы скрипта
# ------------------------------------------------------------------------------------------

MAIN_DNS_PORT=53
LOCALHOST_IP=127.0.0.1

DNS_IP_PORT="${LOCALHOST_IP}#${MAIN_DNS_PORT}"
CMD_LIST="address prefix name-servers"


# ------------------------------------------------------------------------------------------
#
# 	Производим инициализацию пакета КВАС
#
# ------------------------------------------------------------------------------------------
cmd_kvas_init(){
	stage="${1:-no}"
	prefix=''
	mess="${prefix}Производим сброс пакета КВАС в исходное состояние."
	warning "${mess}";
#	log_alert "${mess}"
	print_line

	recreate_ip4tables

	if has_ssr_enable; then
		recreate_ssr_rules

	else
		recreate_vpn_rules
	fi

	ready "${prefix}Заполняем ipset таблицу данными из списка разблокировки."
	/opt/apps/kvas/bin/main/ipset &> /dev/null &
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	if [ -f /opt/etc/init.d/S56dnsmasq ] ; then
		refresh_dnsmasq_ipset_table
	else
		refresh_adguard_ipset_table
		[ "${stage}" = initd ] || {
			ready "${prefix}Перезапускаем сервис AdGuard Home"
			/opt/etc/init.d/S99adguardhome restart &>/dev/null && when_ok "ГОТОВО" || when_bad "ОШИБКА"
		}
	fi
	. /opt/apps/kvas/bin/libs/adblock
	if cmd_ads_status | grep -q 'ВКЛЮЧЕНА' ; then
		ready "${prefix}Обновляем данные списка блокировки рекламы."
		/opt/apps/kvas/bin/main/adblock &>/dev/null && when_ok "ГОТОВО" || when_bad "ОШИБКА"
	fi

	ready "${prefix}Синхронизируем дату роутера с сервером времени."
	date_update &>/dev/null && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	! [ "${stage}" = update ] && {
		ready "${prefix}Производим перезапуск подключения к интернету"
		reset_ISP_connection && when_ok "ГОТОВО" || when_bad "ОШИБКА"
	}

	log_alert "${prefix}Сброс пакета КВАС в исходное состояние ЗАВЕРШЕНА!"

}

SUFF=">> "
# ------------------------------------------------------------------------------------------
#
#	Выводим предупреждение в случае, если пользователь
#	запускает команду для другого DNS сервиса и возвращаем
#	статус запущенной службы в случае, когда запущен именно AdGuard Home
#
# ------------------------------------------------------------------------------------------
exit_when_adguard_on(){
	if cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
		echo -e "${SUFF}${BLUE}Сейчас функции DNS сервера, шифрования DNS трафика и функции блокировки рекламы ${NOCL}"
		echo -e "${SUFF}${BLUE}исполняет AdGuard Home, заменяющий связку [dnsmasq + dnscrypt_proxy2 + adblock].${NOCL}"
		echo -e "${SUFF}${BLUE}Единовременно Квас может работать только с одной из этих связок.${NOCL}"
		echo -e "${SUFF}${BLUE}Для перехода на связку с dnsmasq запустите команду ${GREEN}kvas adguard off${NOCL}"
        eval "${1}=1"; else
        eval "${1}=0";
    fi
}
exit_when_dnsmasq_on(){
	if ! cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
		echo -e "${SUFF}${BLUE}Сейчас функции DNS сервера, шифрования DNS трафика и функции блокировки рекламы${NOCL}"
		echo -e "${SUFF}${BLUE}исполняет связка [dnsmasq + dnscrypt_proxy2 + adblock], заменяющая AdGuard Home.${NOCL}"
		echo -e "${SUFF}${BLUE}Единовременно Квас может работать только с одной из этих связок.${NOCL}"
		echo -e "${SUFF}${BLUE}Для перехода на AdGuard Home запустите команду ${GREEN}kvas adguard on${NOCL}"
        eval "${1}=1"; else
        eval "${1}=0";
    fi
}


ip4() (/opt/sbin/ip -4 "$@")
# ------------------------------------------------------------------------------------------
#
#	Функция вывода помощи по работе скрипта
#
# ------------------------------------------------------------------------------------------
cmd_help() {
	cat < "/opt/apps/${APP_NAME}/etc/conf/${APP_NAME}.help"
}



# ------------------------------------------------------------------------------------------
#
#	Получаем значение любого параметра заданного CLI интерфейса
#	$1 - ID CLI интерфейса с учетом регистра
#	$2 - название параметра
#
# ------------------------------------------------------------------------------------------
get_value_interface_field() {
	id_cli_inface=${1}
	field_name=${2}
	sleep 1
	curl -s "${INFACE_REQUEST}" | jq -r '.[] | select(.id=="'"${id_cli_inface}"'") | .'"${field_name}"
}
# ------------------------------------------------------------------------------------------
#
#	Получаем текущий интерфейс по умолчанию через который раздается интернет
#
# ------------------------------------------------------------------------------------------
get_defaultgw_interface() {
	curl -s "${INFACE_REQUEST}" | jq -r '.[] | select(.defaultgw==true and .global==true) | ."interface-name"'
}
# ------------------------------------------------------------------------------------------
#
#	Получаем текущий id по умолчанию через который раздается интернет
#
# ------------------------------------------------------------------------------------------
get_defaultgw_id() {
	curl -s "${INFACE_REQUEST}" | jq -r '.[] | select(.defaultgw==true and .global==true) | .id'
}

# ------------------------------------------------------------------------------------------
#
#	Функция вЫключения IPv6
#	$1 - CLI интерфейс
#
# ------------------------------------------------------------------------------------------
ipv6_inface_off() {

	inface="${1}"
	if [ -n "${inface}" ]; then
		ready "Поддержка IPv6 на интерфейсе ${inface} отключена"
		for cmd in ${CMD_LIST}; do
	#		для отключения инфейса необходимо отправить команду no
	#		по всем командам ipv6: address prefix name-servers
			curl -s -d '{"auto":true,"no":true}' "${INFACE_PART_REQUEST}/${inface}/ipv6/${cmd}" &> /dev/null
		done
		if [ $? = 0 ]; then when_ok "УСПЕШНО"; else when_bad "СБОЙ"; fi
	else
		when_bad "СБОЙ" && error "Не задан интерфейс"
	fi

}
# ------------------------------------------------------------------------------------------
#
#	Функция включения IPv6
#	$1 - CLI интерфейс
#
# ------------------------------------------------------------------------------------------
ipv6_inface_on() {
	inface="${1}"
#	Проверка на наличие заданного интерфейса в роутере
	if is_cli_inface_present "${inface}"; then
		if [ -n "${inface}" ]; then
			ready "Поддержка IPv6 на интерфейсе ${inface} подключена"
				for cmd in ${CMD_LIST}; do
		#		для отключения инфейса необходимо отправить команду auto
		#		по всем командам ipv6: address prefix name-servers
					curl -s -d '{"auto":true}' "${INFACE_PART_REQUEST}/${inface}/ipv6/${cmd}" &> /dev/null
				done
			if [ $? = 0 ]; then when_ok "УСПЕШНО"; else when_bad "СБОЙ"; fi
		else
			when_bad "СБОЙ" && error "Не задан интерфейс"
		fi
	else
		when_bad "СБОЙ" && error "Заданный интерфейс ${inface} не существует"
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Функция проверки статуса IPv6
#	$1 - CLI интерфейс
#	Возвращает:
#	0 - ipv6 подключен
#	1- ipv6 отключен
#	2 - ipv6 не совместим с указанным интерфейсом
#
# ------------------------------------------------------------------------------------------
ipv6_status() {
	inface="${1}"; res=0
	if [ -n "${inface}" ]; then
		for cmd in ${CMD_LIST}; do
			#		для отключения инфейса необходимо получить ответ true
			#		по всем командам ipv6: address prefix name-servers
			request=$(curl -s "${INFACE_PART_REQUEST}/${inface}/ipv6/${cmd}")
#			если интерфейс не совместим с IPV6, то выходим из цикла
			echo "${request}" | grep -q 'not IPv6 compatible' && res=-1 && break
			echo "${request}" | grep -q true && res=$((res+1))

		done
#		если вернем 1 - то IPv6 отключен
#		если вернем 0 - то IPv6 включен
#		если вернем 2 - то IPv6 несовместим с указанным интерфейсом
		[ "${res}" -eq 3 ] && echo 0
		[ "${res}" -eq -1 ] && echo 2
		[[ "${res}" -ge 0 ]] && [[ "${res}" -lt 3 ]] && echo 1

	else
		when_bad "СБОЙ"
		error "Не задан интерфейс"
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Функция проверки фактического наличия в списке доступного CLI интерфейса
#	$1 - CLI интерфейс
#
# ------------------------------------------------------------------------------------------
is_cli_inface_present() {
	inface="${1}"
	if [ -n "${inface}" ]; then
		curl -s "${INFACE_REQUEST}" | grep interface-name | grep -q "${inface}"
	else
		when_bad "СБОЙ"
		error "Не задан интерфейс"
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Функция проверки включен ли на заданном CLI интерфейсе поддержка IPv6
#	$1 - CLI интерфейс
#
# ------------------------------------------------------------------------------------------
ipv6_inface_status() {
	inface="${1}"
	if [ -n "${inface}" ]; then
		if is_cli_inface_present "${inface}" ; then
			ready "IPv6 на интерфейсе ${inface}"
			ipv6_status=$(ipv6_status "${inface}")
			[ "${ipv6_status}" -eq 0 ] && when_ok "ПОДКЛЮЧЕН"
			[ "${ipv6_status}" -eq 1 ] && when_alert "ОТКЛЮЧЕН"
			[ "${ipv6_status}" -eq 2 ] && when_bad "НЕ ВОЗМОЖЕН"
		else
			error "Указанный интерфейс ${inface} в системе не существует."
			exit 1
		fi
	else
		when_bad "СБОЙ"
		error "Не задан интерфейс"
		exit 1
	fi

}

# ------------------------------------------------------------------------------------------
#
#	 Меняем в файле конфигурации AdGuard Home DNS его адрес, в случае если он равен 0.0.0.0
# 	 Предотвращаем зависание работы пакета при выборе пользователем,
# 	 при первоначальной настройке AdGuard Home, опцию "все адреса"
#
# ------------------------------------------------------------------------------------------
adguardhome_change_and_get_config_ip() {
	ip_filter="[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}"
	ip_dns_adguard=$(cat < "${ADGUARDHOME_CONFIG}" | sed -n '/^dns/,/port:/p' | grep -o "${ip_filter}")
#	Если DNS порт установлен в значение 0.0.0.0 (все адреса), то меняем его на ip роутера
	if [ "${ip_dns_adguard}" = '0.0.0.0' ] ; then
		ip_dns_adguard=$(get_router_ip)
		sed -i '/^dns/,/port:/s/'"${ip_filter}/${ip_dns_adguard}"'/' "${ADGUARDHOME_CONFIG}"
	fi
	echo "${ip_dns_adguard}"
}

# ------------------------------------------------------------------------------------------
#
#	 Производим настройку работы AdGuard Home
# 	 $1 - содержит 'ip:port' для работы adguardhome
#
# ------------------------------------------------------------------------------------------
adguardhome_setup() {

	ip=$(adguardhome_change_and_get_config_ip)
	port=${MAIN_DNS_PORT}

	ready "AdGuard Home установлен в качестве основного DNS сервера"

#	в случае установленного dnsmasq останавливаем его и архивируем
	[ -f /opt/etc/init.d/S56dnsmasq ] && {
		/opt/etc/init.d/S56dnsmasq stop &> /dev/null
		mv -f /opt/etc/init.d/S56dnsmasq "${KVAS_BACKUP_PATH}"
	}
#	в случае наличия сервиса dnscrypt_proxy2 останавливаем его и архивируем
	[ -f /opt/etc/init.d/S09dnscrypt-proxy2 ] && {
		/opt/etc/init.d/S09dnscrypt-proxy2 stop &> /dev/null
		mv -f /opt/etc/init.d/S09dnscrypt-proxy2 "${KVAS_BACKUP_PATH}"
	}
#   останавливаем adg сервис, если он запущен
	${ADGUARDHOME_DEMON} stop &> /dev/null
#	устанавливаем DNS по умолчанию на ADGUARD
	set_config_value DNS_DEFAULT "${ip}#${port}"
#	меняем номер порта в файле конфигурации adguard
	sed -i "s/\( port:\) .*/\1 ${port}/" "${ADGUARDHOME_CONFIG}"
#	если файл сервис adguard в наличии то архивируем файл конфигурации
	if [ -f "${ADGUARDHOME_DEMON}" ]; then
		cp /opt/etc/AdGuardHome/AdGuardHome.yaml "${KVAS_BACKUP_PATH}"/AdGuardHome.yaml
	fi
#	и копируем подготовленный файл сервиса adguard в папку запуска сервисов
#	проверяем файл на оригинальность (без переделок ли он под квас)
	if ! cat < "${ADGUARDHOME_DEMON}" | grep -q kvas ; then
#		если оригинальный, то архивируем его
		mv "${ADGUARDHOME_DEMON}" "${KVAS_BACKUP_PATH}/S99adguardhome.origin"
	fi
	cp /opt/apps/kvas/etc/init.d/S99adguard "${ADGUARDHOME_DEMON}"
#	удаляем сервис запуска квас так как его теперь будет заменять файл сервиса adguard
	rm -f "${KVAS_START_FILE}"
#	меняем dns в настройках ipset
	ipset_dns_change "${ip}#${port}"
#	теперь просто запускаем сервис adguard
#	ndm_interface_change

#	Обновляем правила ip4tables для доступного соединения
	ip4_firewall_flush_all_rules
	ip4_firewall_set_all_rules

	"${ADGUARDHOME_DEMON}" start &> /dev/null
#	отслеживаем результат запуска сервиса adguard
	if [ $? = 0 ]; then
		when_ok "УСПЕШНО"
	else
		when_bad "СБОЙ";
		error "Возникла ошибка при установке AdGuard Home в качестве основного DNS сервера."
		exit 1
	fi
}
# ------------------------------------------------------------------------------------------
#
#	 Возвращаем IP#port на котором слушает AdGuard Home в качестве основного DNS сервера
#	 в виде XXX.XXX.XXX.XXX#53
#
# ------------------------------------------------------------------------------------------
get_adguardhome_ip_port() {
	dns_ip="$(cat < "${ADGUARDHOME_CONFIG}" | grep '^bind_host: ' | cut -d':' -f2 | tr -d ' \n')"
	echo "${dns_ip}" | grep -q '0.0.0.0' && dns_ip=$(get_router_ip)
	echo "${dns_ip}#${MAIN_DNS_PORT}"
}
# ------------------------------------------------------------------------------------------
#
#	 Возвращаем статус AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
cmd_adguardhome_status() {
	ready "Сервис AdGuard Home "
	# Проверяем наличие исполняемого файла AdGuardHome
	if [ -f /opt/bin/AdGuardHome ] ; then
#		Проверяем наличие файла конфигурации AdGuardHome
		if [ -f /opt/etc/AdGuardHome/AdGuardHome.yaml ]; then
#			Проверяем наличие сервиса AdGuardHome
			if [ -f "${ADGUARDHOME_DEMON}" ] ; then
				DNS_IP_PORT=$(get_adguardhome_ip_port)
				adguard_is_dns_default=$(get_config_value 'DNS_DEFAULT' | grep "${DNS_IP_PORT}")
				adguard_is_alive=$("${ADGUARDHOME_DEMON}" status | grep alive)

				if [ -n "${adguard_is_dns_default}" ] && [ -n "${adguard_is_alive}" ];
				then when_ok "ВКЛЮЧЕН";
				else when_bad "ОТКЛЮЧЕН"; fi
			else
				when_bad "НУЖНО ПЕРЕУСТАНОВИТЬ"
			fi
		else
			when_bad "НЕ НАСТРОЕН"
		fi
	else
		when_bad "НЕ УСТАНОВЛЕН"
	fi

}
# ------------------------------------------------------------------------------------------
#
#	 Производим настройку AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
adguardhome_check_config() {
		# Проверяем наличие	архивной копии AdGuardHome
		if [ -f "${KVAS_BACKUP_PATH}"/AdGuardHome.yaml ]; then
			cp "${KVAS_BACKUP_PATH}"/AdGuardHome.yaml /opt/etc/AdGuardHome/AdGuardHome.yaml
			"${ADGUARDHOME_DEMON}" restart  &> /dev/null
			ip=$(get_router_ip)
			port=$(cat < "${ADGUARDHOME_CONFIG}" | grep '^bind_port: ' | cut -d':' -f2 | tr -d ' \n')
			echo -e "Был обнаружен и восстановлен архивный файл конфигурации AdGuard Home."
			echo -e "Панель управления находится по адресу: ${BLUE}http://${ip}:${port}${NOCL}"
			print_line
		else
			[ -f /opt/etc/init.d/S56dnsmasq ] && /opt/etc/init.d/S56dnsmasq stop &> /dev/null
			[ -f /opt/etc/init.d/S09dnscrypt-proxy2 ] && /opt/etc/init.d/S09dnscrypt-proxy2 stop &> /dev/null
			rm -f /opt/var/log/AdGuardHome.log
#			Проверяем наличие файла конфигурации AdGuardHome в папке исполняемых файлов
			if [ -f /opt/bin/AdGuardHome.yaml ]; then
#				проверяем файл на оригинальность (без переделок ли он под квас)
				if ! cat < "${ADGUARDHOME_DEMON}" | grep -q kvas ; then
#					если оригинальный, то архивируем его
					mv "${ADGUARDHOME_DEMON}" "${KVAS_BACKUP_PATH}/S99adguardhome.origin"
				fi

				cp /opt/apps/kvas/etc/init.d/S99adguard  /opt/etc/init.d/S99adguardhome
				mv /opt/bin/AdGuardHome.yaml /opt/etc/AdGuardHome/AdGuardHome.yaml
				"${ADGUARDHOME_DEMON}" restart  &> /dev/null
			else
				echo "Следуйте инструкциям на экране ниже..."
				echo "После всех произведенных настроек нажмите Ctrl-C"
#				echo -e "И затем снова запустите ${BLUE}kvas adguard on${NOCL}"
				print_line
				/opt/bin/AdGuardHome && cmd_adguardhome_on
			fi
		fi
}
# ------------------------------------------------------------------------------------------
#
#	 Производим локальную установку AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
adguardhome_install_locally() {

	if [ -f /opt/tmp/opkg.lock ]; then
		echo "Установите AdGuard Home на роутер после завершения установки пакета"
		echo -e "Для этого наберите команду ${GREEN}opkg install adguardhome-go${NOCL}"
		echo "и следуйте рекомендациям на экране, после настройки AdGuard Home"
		echo "запустите команду ${GREEN}kvas adguard on${NOCL}."
	else
		[ -f /opt/etc/init.d/S56dnsmasq ] && /opt/etc/init.d/S56dnsmasq stop &> /dev/null
		[ -f /opt/etc/init.d/S09dnscrypt-proxy2 ] && /opt/etc/init.d/S09dnscrypt-proxy2 stop &> /dev/null
		rm -f /opt/var/log/AdGuardHome.log
		opkg remove adguardhome-go &> /dev/null
		opkg install adguardhome-go &> /dev/null
		. /opt/apps/kvas/bin/libs/update
		cmd_adguard_update
		adguardhome_check_config
		ip=$(get_router_ip)
		port=$(cat < "${ADGUARDHOME_CONFIG}" | grep '^bind_port: ' | cut -d':' -f2 | tr -d ' \n')
		adguardhome_setup
	fi
}

# ------------------------------------------------------------------------------------------
#
#	 Включаем работу AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
cmd_adguardhome_on() {

	status=$(cmd_adguardhome_status)
	if echo "${status}" | grep -q "НЕ УСТАНОВЛЕН" ; then
		echo "Пакет AdGuard Home не установлен на роутере."
		answer=''; read_ynq "Установить его на роутер [Y] или отказаться [N]?" answer
		if [ "${answer}" = y ]; then
			adguardhome_install_locally
		fi
	elif echo "${status}" | grep -q "НЕ НАСТРОЕН" ; then
		adguardhome_check_config
		adguardhome_setup
	elif  echo "${status}" | grep -q "НУЖНО ПЕРЕУСТАНОВИТЬ" ; then
		adguardhome_install_locally
	else
		adguardhome_setup
	fi
}
# ------------------------------------------------------------------------------------------
#
#	 Выключаем работу AdGuard Home в качестве основного DNS сервера
#
# ------------------------------------------------------------------------------------------
cmd_adguardhome_off(){
	ready "AdGuard Home в качестве DNS сервера удален"
	[ -f "${ADGUARDHOME_CONFIG}" ] && sed -i "s/\( port:\) .*/\1 0/" "${ADGUARDHOME_CONFIG}"
	${ADGUARDHOME_DEMON} stop &> /dev/null
	[ -f "${ADGUARDHOME_CONFIG}" ] && mv -f "${ADGUARDHOME_CONFIG}" "${KVAS_BACKUP_PATH}/AdGuardHome.yaml"
	[ -f /opt/etc/init.d/S56dnsmasq ] && /opt/etc/init.d/S56dnsmasq stop &> /dev/null
	[ -f /opt/etc/init.d/S09dnscrypt-proxy2 ] && /opt/etc/init.d/S09dnscrypt-proxy2 stop &> /dev/null
	cp /opt/apps/kvas/etc/init.d/S96kvas "${KVAS_START_FILE}"
	dnsmasq_install '' &> /dev/null
	#	Обновляем правила ip4tables для доступного соединения
	ip4_firewall_flush_all_rules
	ip4_firewall_set_all_rules

	if [ $? = 0 ]; then
		when_ok "УСПЕШНО"
		dns_crypt_install ''
	else
		when_bad "С ОШИБКОЙ";
		error "Возникла ошибка при удалении AdGuard Home из системы."
		exit 1
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Функция подключает гостевую сеть к активному vpn
#	$1 - ID гостевого моста в entware
#
# ------------------------------------------------------------------------------------------
bridge_vpn_access_del() {
	guest_bridge_id="${1}"
	ready "Удаление гостевого интерфейса ${guest_bridge_id} из vpn цепочки завершено"

	if [ -f "${DNS_LOCAL_DEMON_FILE}" ]; then
		sed -i "/PREROUTING -i ${guest_bridge_id}/d" "${DNS_LOCAL_DEMON_FILE}"
	fi
	if [ -f "${IPSET_REDIRECT_DEMON_FILE}" ]; then
		sed -i "/PREROUTING -i ${guest_bridge_id}/d" "${IPSET_REDIRECT_DEMON_FILE}"
	fi
	sed -i "s/\(interface=.*\),${guest_bridge_id}/\1/" "${DNSMASQ_CONFIG}"
	[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}
# ------------------------------------------------------------------------------------------
#
#	Функция выводит список гостевых сетей в наличии
#
# ------------------------------------------------------------------------------------------
cmd_bridge_vpn_access_list() {

	num_id_local_inface=$(get_local_inface | tr 'a-zA-Z' ' ' | tr -d ' ')
	entware_bridge_list=$(ip4 a \
						| grep -E ': br[0-9]' \
						| grep -v "br${num_id_local_inface}" \
						| cut -d':' -f1-2 \
						| cut -d' ' -f2\
						| tr '\n' ' ' \
						)
	num=0
	for bridge_id in ${entware_bridge_list}; do
		num=$((num + 1))
		net=$(ip4 a | grep " ${bridge_id}" | grep inet | sed 's/^ *//' | cut -d' ' -f2)
		num_inface=$(echo "${bridge_id}" | tr -d '[:alpha:]')
        desc=$(curl -s "${INFACE_REQUEST}/Bridge${num_inface}" | grep '"description":' | cut -d':' -f2 |  sed 's/[,"]//g; s/^[ ]//')
        ready "${num}. Интерфейс '${desc}::Bridge${num_inface}' [${net}]"
		grep 'interface=' "${DNSMASQ_CONFIG}" | grep -q "${bridge_id}" && when_ok "ПОДКЛЮЧЕН" || when_bad "ОТКЛЮЧЕН"
	done
#	echo "${guest_bridge_list_id}"
}
# ------------------------------------------------------------------------------------------
#
#	Функция подключает гостевую сеть к активному vpn
#
#	$1 - команда для удаления всех гостевых сетей к активному vpn
#	$2 - команда для обновления внесенных изменений
#	внесена для того, чтобы предотвратить обновления
#	при использовании в функции cmd_bridge_vpn_access_add
#
# ------------------------------------------------------------------------------------------
cmd_bridge_vpn_access_del() {

	option=${1}; cmd="${2:-update}"; guest_bridge_id=''
	guest_bridge_list_id=$(cat < "${DNSMASQ_CONFIG}" \
						  | grep -E 'interface=br[0-9]' \
						  | sed 's/\(interface=br[0-9]\)\(.*\)/\2/'\
						  | cut -d',' -f2- \
						  | tr ',' ' ' \
						  )
	if [ "${option}" = all ]; then
		for bridge_id in ${guest_bridge_list_id}; do
			bridge_vpn_access_del "${bridge_id}"
		done
	elif [ -n "${option}" ] && echo "${option}" | grep -qi 'br'; then
		bridge_vpn_access_del "${option}"
	else
		count_infaces=$(echo "${guest_bridge_list_id}" | wc -w)
		if [ "${count_infaces}" -gt 1 ]; then
			bridge_inface_select guest_bridge_id
		else
			guest_bridge_id=${guest_bridge_list_id}
		fi
		if [ -n "${guest_bridge_id}" ]; then
			bridge_vpn_access_del "${bridge_id}"
		fi
	fi
	if [ -n "${guest_bridge_id}" ] && [ "${cmd}" = update ]; then cmd_kvas_init ; fi
}


# ------------------------------------------------------------------------------------------
#
#	Функция подключает гостевую сеть к активному vpn
#	$1 - ID гостевого моста в entware
#
# ------------------------------------------------------------------------------------------
bridge_access_add() {

	guest_bridge_id=${1}; ip=${2}; crypt_port=${3}

	has_ssr_enable && vpn_type='shadowsocks' || vpn_type='vpn'

	ready "Добавление гостевого интерфейса ${guest_bridge_id} в ${vpn_type} цепочку завершено"

	has_guest_nets=$(cat ${KVAS_CONF_FILE} | sed -n 's/INFACE_GUEST_ENT=\(.*\)/\1/p')
	[ -n "${has_guest_nets}" ] && point=',' || point=''
	sed -i "s/\(INFACE_GUEST_ENT=.*\)/\1${point}${guest_bridge_id}/g" ${KVAS_CONF_FILE}

	if has_ssr_enable; then
		ip4_add_guest_to_vpn_network
	else
		ip4_add_guest_to_ssr_network
	fi
	[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}
# ------------------------------------------------------------------------------------------
#
#	Обертка вокруг функции добавления гостевых сетей к активному vpn
#	$1 - команда для добавления всех гостевых сетей к активному vpn
#
# ------------------------------------------------------------------------------------------
cmd_bridge_vpn_access_add() {

	option=${1};

	ip=$(get_router_ip)
	crypt_port=$(get_config_value DNS_CRYPT_PORT)

	if [ -n "${option}" ] && [ "${option}" = all ]; then
		cmd_bridge_vpn_access_del 'all' 'not_update' &> /dev/null
		num_id_local_inface=$(get_local_inface | tr 'a-zA-Z' ' ' | tr -d ' ')
		entware_bridge_list=$(ip4 a \
							| grep -E ': br[0-9]' \
							| grep -v "br${num_id_local_inface}" \
							| cut -d':' -f1-2 \
							| cut -d' ' -f2\
							| tr '\n' ' ' \
						 	)
		for bridge_id in ${entware_bridge_list}; do
			bridge_access_add "${bridge_id}" "${ip}"
		done
		cmd_kvas_init ''
	else
		guest_bridge_id=''; bridge_inface_select guest_bridge_id
		if [ -n "${guest_bridge_id}" ]; then
			# cmd_bridge_vpn_access_del "${guest_bridge_id}" 'not_update' &> /dev/null
			bridge_access_add "${guest_bridge_id}" "${ip}"
			cmd_kvas_init
		fi
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Функция подключает гостевую сеть к активному vpn
#	$1 - переменная для записи ID гостевого моста в entware
#
# ------------------------------------------------------------------------------------------
bridge_inface_select() {

	num_id_local_inface=$(get_local_inface | tr 'a-zA-Z' ' ' | tr -d ' ')
	entware_bridge_list=$(ip4 a \
							| grep -E ': br[0-9]' \
							| grep -v "br${num_id_local_inface}" \
							| cut -d':' -f1-2 \
							| cut -d' ' -f2\
							| tr '\n' ' ' \
						 )
	cli_bridge_list=$(curl -s "${INFACE_REQUEST}" \
						| grep 'id":' \
						| grep -iE 'bridge[0-9]' \
						| grep -vi "bridge${num_id_local_inface}" \
						| cut -d ':' -f2 \
						| tr -d ' ",:'\
						| tr '\n' ' ' \
					  )
	total=$(echo "${entware_bridge_list}" | wc -w)

	if [ "${total}" -gt 0 ]; then
		num=0;
		for cli_inface in ${cli_bridge_list}; do
			num=$((num + 1))
			num_inface=$(echo "${cli_inface}" | tr -d '[:alpha:]')
			net=$(ip4 a | grep " br${num_inface}" | grep inet | sed 's/^ *//' | cut -d' ' -f2)
			mess="${num}. Интерфейс ${cli_inface} -> ${net}"
			connected=$(is_vpn_interface_connected "${cli_inface}")
			ready "${mess}"
			if [ "${connected}" = "on" ]; then when_ok "В СЕТИ"; else when_bad "ОТКЛЮЧЕН"; fi
		done

		while true; do
			print_line
			#warning "Зеленым цветом выделен текущий интерфейс"
			ready "Выберите номер интерфейса [1-${total}, Q-выход]:"
			read -r num_inface
			case "${num_inface}" in
				[qQ]*) break ;;
				[1-${total}]* )  eval "${1}=$(echo "${entware_bridge_list}" \
								| cut -d ' ' -f"${num_inface}")"; break ;;
				* ) error "Введите цифру от 1 до ${total}." ;;
			esac
		done
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Меняем текущий DNS в настройках ipset на новый
#
#	$1 - новый DNS
#
# ------------------------------------------------------------------------------------------
ipset_dns_change() {
	dns_new=${1};
	if echo "${dns_new}" | grep -qE ':|#'; then
		_dns_clear=$(echo "${dns_new}" | tr '#' ':' )
		sed -i "s/@[a-zA-Z0-9:.]*/@${_dns_clear}/" "/opt/apps/kvas/bin/main/ipset"
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Устанавливаем dnsmasq в систему
#
#	$1 - наличие значения данной переменной говорит о том,
#	что вызов данной функции был произведен при инсталляции пакета
#
# ------------------------------------------------------------------------------------------
dnsmasq_install(){
	is_install_stage="${1}"

	if [ -f /opt/etc/init.d/K56dnsmasq ]; then
		cp /opt/etc/init.d/K56dnsmasq /opt/etc/init.d/S56dnsmasq
	else
		if ! [ -f "/opt/etc/init.d/S56dnsmasq" ]; then
			ready "Устанавливаем пакет dnsmasq..."
			if ! [ -f /opt/etc/init.d/S56dnsmasq ]; then
#				то в этом случае можем попытаться удалять или устанавливать пакеты
				opkg remove dnsmasq 1> /dev/null 2> "${ERROR_LOG_FILE}"
				opkg install dnsmasq 1> /dev/null 2> "${ERROR_LOG_FILE}"
				when_error "${?}" "Ошибка при установке пакета dnsmasq"
			fi
		fi
	fi
	if /opt/etc/init.d/S56dnsmasq status | grep -q alive ; then
		ready "Останавливаем сервис dnsmasq..."
		/opt/etc/init.d/S56dnsmasq stop 1> /dev/null 2> "${ERROR_LOG_FILE}"
		ready_status "${?}" "Невозможно остановить сервис dnsmasq"
	fi
	ready "Заменяем файл конфигурации dnsmasq...   "
	[ -f /opt/etc/dnsmasq.conf ] && mv -f /opt/etc/dnsmasq.conf "${KVAS_BACKUP_PATH}/dnsmasq.conf" 1> /dev/null 2> "${ERROR_LOG_FILE}"
	[ -f /opt/sbin/dnsmasq ] && mv -f /opt/sbin/dnsmasq "${KVAS_BACKUP_PATH}/dnsmasq" 1> /dev/null 2> "${ERROR_LOG_FILE}"
	cp /opt/apps/kvas/etc/conf/dnsmasq.conf /opt/etc/dnsmasq.conf 1> /dev/null 2> "${ERROR_LOG_FILE}"
	ready_status "${?}" "Проблемы при замене в файле конфигурации dnsmasq"

	ready "Меняем dnsmasq на версию с поддержкой wildcard"
	bin_path="/opt/apps/kvas/sbin/dnsmasq"
	chmod -R +x "${bin_path}"
	arch=$(grep "arch" /opt/etc/entware_release | cut -f2 -d"=")
	case "${arch}" in
		mips) cp ${bin_path}/mips /opt/sbin/dnsmasq 1> /dev/null 2> "${ERROR_LOG_FILE}";;
		mipsel) cp ${bin_path}/mipsel /opt/sbin/dnsmasq 1> /dev/null 2> "${ERROR_LOG_FILE}";;
		aarch64) cp ${bin_path}/aarch64 /opt/sbin/dnsmasq 1> /dev/null 2> "${ERROR_LOG_FILE}";;
		*) 	when_bad "ОШИБКА"
			mess="Неизвестная архитектура процессора: ${arch}!"
			warning "${mess}"
			log_in_file "ОШИБКА: ${mess}"
			exit 1
		;;
	esac
	ready_status "${?}" "Проблема при замене dnsmasq на версию с поддержкой wildcard"

	uplevel_dns=$(get_config_value DNS_DEFAULT)
	local_ip=$(get_router_ip)
	inface=$(get_inface_by_ip "${local_ip}")

	ready "Настройка файлов конфигурации dnsmasq"
	sed -i "s/@LOCAL_IP/${local_ip}/g; s/@INFACE/${inface}/g; s/@UPLEVEL_DNS/${uplevel_dns}/g;" /opt/etc/dnsmasq.conf 1> /dev/null 2> "${ERROR_LOG_FILE}"
	ready_status "${?}" "Проблема при настройке файлов конфигурации dnsmasq"
	# Если запуск функции был не при установке пакета Квас
	[ -z "${is_install_stage}" ] && cmd_kvas_init

}
# ------------------------------------------------------------------------------------------
#
#	Меняем текущий DNS на dnsmasq на новый
#
#	$1 - новый DNS
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
dnsmasq_dns_change() {
	dns_new=${1}; cmd=${2:-restart};
	ready "Замена DNS на ${dns_new} в dnsmasq завершена"
	sed -i "s/\(server=\).*/\1${dns_new}/"  "${DNSMASQ_CONFIG}"
	ipset_dns_change "${dns_new}"
	set_config_value DNS_DEFAULT "${dns_new}"
	/opt/etc/init.d/S56dnsmasq restart &> /dev/null
#	[ "${cmd}" = restart ] && cmd_update_list &> /dev/null
	[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}
# ------------------------------------------------------------------------------------------
#
#	Меняем текущий DNS на dnsmasq на новый
#
#	$1 - новый DNS
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
cmd_dnsmasq_dns_change() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {
		dns_new=${1}; cmd=${2:-restart}
		if [ -z "${dns_new}" ]; then
			dns_show
		else
			dnsmasq_dns_change "${dns_new}" "${cmd}"
		fi
	}
}

# ------------------------------------------------------------------------------------------
#
#	Отображаем текущий IP, который слушает в dnsmasq
#
# ------------------------------------------------------------------------------------------
cmd_dnsmasq_listen_show() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {
		ready "DNSMASQ слушает адрес"
		ip=$(get_config_value DNSMASQ_LISTEN_IP)
		when_alert "${ip}"
	}
}


# ------------------------------------------------------------------------------------------
#
#	Меняем текущий порт dnsmasq на новый
#
# 	$1 - новый номер порта
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
cmd_dnsmasq_port_change() {

	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		port=${1}; cmd=${2:-restart}
		if [ -z "${port}" ]; then
			cmd_dnsmasq_port_show
		else
			ready "Замена порта на ${port} в dnsmasq завершена"
			sed -i "s/\(port=\).*/\1${port}/"  "${DNSMASQ_CONFIG}"
			set_config_value DNSMASQ_PORT "${port}"
			[ "${cmd}" = restart ] && cmd_kvas_init  &> /dev/null
			[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
		fi
	}
}
# ------------------------------------------------------------------------------------------
#
#	Отображаем текущий порт, который слушает в dnsmasq
#
# ------------------------------------------------------------------------------------------
cmd_dnsmasq_port_show() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		ready "DNSMASQ слушает порт"
		port=$(get_config_value DNSMASQ_PORT)
		when_alert "${port}"
	}
}

# ------------------------------------------------------------------------------------------
#
#	Отображаем текущий DNS, установленный в dnsmasq
#
# ------------------------------------------------------------------------------------------
cmd_dns_test() {
	domain=${1:-facebook.com}
	ready "Тестируем получение адреса домена ${domain}"
	result=$(test_host "${domain}" ip)
	[ -n "${result}" ] && when_alert "${result}" || when_bad "ПУСТО"
}
# ------------------------------------------------------------------------------------------
#
#	Отображаем текущий DNS, установленный в dnsmasq
#
# ------------------------------------------------------------------------------------------
dns_show() {
	mess="Текущий DNS сервер по умолчанию"
	if cmd_adguardhome_status | grep -qE "ВКЛЮЧЕН|ОТКЛЮЧЕН" ; then
		DNS_IP_PORT=$(get_adguardhome_ip_port)
	fi
	dns=$(get_config_value DNS_DEFAULT)
	dns_crypt=$(get_config_value DNS_CRYPT_PORT)
	if  echo "${dns}" | grep -q "${dns_crypt}" ; then
		mess="${mess} (dnscrypt_proxy2)"
	elif echo "${dns}" | grep -q "${DNS_IP_PORT}" ; then
		mess="${mess} (AdGuard Home)"
	else
		mess="${mess} (dnsmasq)"
	fi
	ready "${mess}"; when_alert "${dns}"
}

# ------------------------------------------------------------------------------------------
#
#	Чистим таблицу правил iptables для vpn подключений
#
# ------------------------------------------------------------------------------------------
cmd_vpn_iptable_flush() {
	ready "Очистка iptables для vpn завершена"
	ip4_firewall_flush_vpn_rules
	[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
}
# ------------------------------------------------------------------------------------------
#
#	Чистим и заполняем таблицу правил iptables для vpn подключений
#
# ------------------------------------------------------------------------------------------
cmd_vpn_iptable_reset() {
	if [ -f /opt/etc/ndm/fs.d/100-vpn ] ; then
		ready "Переустановка iptables для vpn завершена"
		cmd_vpn_iptable_flush  &> /dev/null
		/opt/etc/ndm/fs.d/100-vpn start &> /dev/null
		[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
	else
		warning "VPN соединение не активно!"
	fi
}
# ------------------------------------------------------------------------------------------
#
#	ВКЛючаем VPN клиента
#	$1 - id интерфейса в entware
#
# ------------------------------------------------------------------------------------------
vpn_off() {
#	ready "Интерфейс vpn отключен "
	rm -f "/opt/etc/ndm/netfilter.d/100-vpn-mark"
	rm -f "/opt/etc/ndm/ifstatechanged.d/100-unblock-vpn"
	rm -f "/opt/etc/ndm/fs.d/100-vpn"
	cmd_vpn_iptable_flush  &> /dev/null
}
# ------------------------------------------------------------------------------------------
#
#	Отображаем статус VPN подключения (тип соединения и его состояние)
#
# ------------------------------------------------------------------------------------------
cmd_vpn_status() {
        vpn_cli_desc=$(get_current_vpn_interface "cli_desc")
        vpn_cli=$(get_current_vpn_interface "cli")
        [ "${vpn_cli}" = 'shadowsocks' ] && inface="SHADOWSOCKS" || inface="${vpn_cli_desc} (${vpn_cli})"
        ready "Текущее VPN соединение: ${BLUE}${inface}${NOCL}"
        [ "$(is_vpn_interface_connected "${vpn_cli}")" = 'on' ] && when_ok "ПОДКЛЮЧЕНО" || when_bad "ОТКЛЮЧЕНО"
}
# ------------------------------------------------------------------------------------------
#
#	Производим замену в библиотеке ndm основных значения интерфейсов
#	$1 - id интерфейса в entware
#
# ------------------------------------------------------------------------------------------
ndm_interface_change() {
	inface_entware="${1}"; inface_cli="${2}"
	cp /opt/apps/${APP_NAME}/etc/ndm/ndm /opt/apps/kvas/bin/libs/ndm
	chmod +x /opt/apps/kvas/bin/libs/ndm
	set_config_value "INFACE_ENT" "${inface_entware}"
	set_config_value "INFACE_CLI" "${inface_cli}"

}
# ------------------------------------------------------------------------------------------
#
#	ВКЛючаем VPN клиента
#	$1 - id интерфейса в entware
#
# ------------------------------------------------------------------------------------------
vpn_on() {

	inface_entware="${1}"
	inface_cli=$(grep "${inface_entware}" "${INFACE_NAMES_FILE}" | cut -d '|' -f1 )
	inface_cli_desc=$(grep "${inface_entware}" "${INFACE_NAMES_FILE}" | cut -d '|' -f3 )

	ready "Интерфейс ${inface_cli_desc} подключен "
	{

		cp "/opt/apps/${APP_NAME}/etc/ndm/fs.d/100-vpn" "/opt/etc/ndm/fs.d/100-vpn"
		chmod +x "/opt/etc/ndm/fs.d/100-vpn"
	#	Производим замену в библиотеке ndm основных значения интерфейсов
		ndm_interface_change "${inface_entware}" "${inface_cli}"

		cp "/opt/apps/${APP_NAME}/etc/ndm/netfilter.d/100-vpn-mark" "/opt/etc/ndm/netfilter.d/100-vpn-mark"
		chmod +x "/opt/etc/ndm/netfilter.d/100-vpn-mark"

		cp "/opt/apps/${APP_NAME}/etc/ndm/ifstatechanged.d/100-unblock-vpn" "/opt/etc/ndm/ifstatechanged.d/100-unblock-vpn"
		chmod +x "/opt/etc/ndm/ifstatechanged.d/100-unblock-vpn"

		state=$(get_value_interface_field "${inface_cli}" state)

		if [ "${state}" = 'down' ]; then
			curl -s -d '{"up":"true"}' "${INFACE_PART_REQUEST}/${inface_cli}" &> /dev/null
		fi
		sleep 2
		connected=$(get_value_interface_field "${inface_cli}" connected)

		if [ "${connected}" = 'no' ]; then

			when_bad "С ОШИБКАМИ"
			error "Возникла ошибка при подключении интерфейса ${inface_entware}!"
			error "Проверьте доступность сервера и настройки клиента!"
			exit 1
		else
			recreate_ip4tables
			recreate_vpn_rules
		fi
	} 1> /dev/null 2> "${ERROR_LOG_FILE}"
	ready_status "${?}" "Возникла ошибка при подключении VPN соединения [${inface_cli_desc}]" "УСПЕШНО"

}

active_backup_config(){
	echo "Обнаружен архивный файл конфигурации shadowsocks."
	answer=''; read_ynq "Удалить его и создать новый" answer
	if [ "${answer}" = y ]; then
		ready "Удаляем архивный файл конфигурации shadowsocks..."
		rm -f "${SHADOWSOCKS_CONF}.kvas"
		[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
	else
		ready "Восстанавливаем файл конфигурации shadowsocks из архива   "
		mv -f "${SHADOWSOCKS_CONF}.kvas" "${SHADOWSOCKS_CONF}"  &>/dev/null
		if [ ${?} = 0 ]; then
			when_ok "ГОТОВО";
		else
			when_bad "ОШИБКА" && exit 1
		fi
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Сохраняем данные для shadowsocks в архивный файл ${SHADOWSOCKS_CONF}.kvas
#
# ------------------------------------------------------------------------------------------
shadowsocks_backup() {
	# Проверяем установлен ли сервис shadowsocks
	if [ -f /opt/bin/ss-redir ] && [ -f /opt/etc/init.d/S22shadowsocks ]; then
		# меняем данные в файлах shadowsocks
		sed -i 's/ss-local/ss-redir/g' /opt/etc/init.d/S22shadowsocks

	#	Проверяем на наличие запуска сервиса shadowsocks
		if /opt/etc/init.d/S22shadowsocks status | grep -q alive ; then
			ready "Останавливаем сервис shadowsocks..."
			if /opt/etc/init.d/S22shadowsocks stop &>/dev/null; then
				when_ok "ГОТОВО"
			else
				when_bad "ОШИБКА"
				error "Невозможно остановить сервис shadowsocks"
				exit 1
			fi
		fi
		if [ -f "${SHADOWSOCKS_CONF}.kvas" ] ; then

			if [ -f "${SHADOWSOCKS_CONF}" ] && ! grep -qE '""|@' "${SHADOWSOCKS_CONF}" && ! grep -qE '127.0.0.1|barfoo!' "${SHADOWSOCKS_CONF}"; then
					active_backup_config
			else
				active_backup_config
			fi


		else
			[ -f "${SHADOWSOCKS_CONF}" ] || shadowsocks_read_data
		fi
	else
		error "Shadowsocks сервис не установлен. Дальнейшая установка невозможна."
		exit 1;
	fi
}


get_ssr_entware_interface()(ip4 a | grep "${SSR_ENTWARE_TEMPL}" | head -1 | cut -d': ' -f2 | tr -d ' ')


shadowsocks_read_config(){

	SSR_SERVER_IP=""; SSR_SERVER_PORT=""; SSR_SERVER_CRYPT=""; SSR_SERVER_PASSWD=""

	read_value "Ведите доменное имя или IP адрес сервера:" SSR_SERVER_IP
	[ "${SSR_SERVER_IP}" = q ] && exit 1
	read_value "Ведите порт сервера:" SSR_SERVER_PORT 'digit'
	[ "${SSR_SERVER_PORT}" = q ] && exit 1
	read_value "Ведите метод шифрования на стороне сервера:" SSR_SERVER_CRYPT
	[ "${SSR_SERVER_CRYPT}" = q ] && exit 1
	read_value "Ведите пароль сервера:" SSR_SERVER_PASSWD 'password'
	[ "${SSR_SERVER_PASSWD}" = q ] && exit 1
	echo

	sed -i "s/\(\"server\":\).*/\1 \"${SSR_SERVER_IP}\",/; 			\
			s/\(\"server_port\":\).*/\1 ${SSR_SERVER_PORT},/; 		\
			s/\(\"local_port\":\).*/\1 $(get_config_value SSR_DNS_PORT),/; 		\
			s/\(\"password\":\).*/\1 \"${SSR_SERVER_PASSWD}\",/; 	\
			s/\(\"method\":\).*/\1 \"${SSR_SERVER_CRYPT}\",/;" 		\
		"${SHADOWSOCKS_CONF}"
}
# ------------------------------------------------------------------------------------------
#
#	Меняем данные для shadowsocks соединения
#
# ------------------------------------------------------------------------------------------
cmd_shadowsocks_read_new_data() {

	echo "Для смены shadowsocks сервера необходимо ввести следующие данные:"
	echo -e "${GREEN}Хост или IP${NOCL} shadowsocks сервера, его ${GREEN}порт, пароль доступа${NOCL} и ${GREEN}метод шифрования${NOCL}"

	echo -e "${BLUE}Пожалуйста, последовательно введите эти данные ниже.${NOCL}"
	print_line

	shadowsocks_read_config
	ready "Перезапускаем shadowsocks интерфейс"
	/opt/etc/init.d/S22shadowsocks restart &> /dev/null
	/opt/etc/init.d/S22shadowsocks status &> /dev/null
	if [ $? = 0 ]; then
		when_ok "УСПЕШНО"
	else
		when_bad "ОШИБКА"
		error "Возникла ошибка при подключении shadowsocks интерфейса!"
		error "Проверьте доступность сервера и настройки клиента!"
		exit 1
	fi

}
# ------------------------------------------------------------------------------------------
#
#	Отключаем shadowsocks клиента
#
# ------------------------------------------------------------------------------------------
shadowsocks_read_data() {

	echo "Чтобы продолжить работу необходимо ввести следующие данные:"
	echo -e "${GREEN}Хост${NOCL} сервера, его ${GREEN}порт, пароль доступа${NOCL} и ${GREEN}метод шифрования${NOCL}"

	echo -e "${BLUE}Пожалуйста, последовательно введите эти данные ниже.${NOCL}"
	print_line

	#	устанавливаем новую конфигурацию shadowsocks
	cp "/opt/apps/${APP_NAME}/etc/conf/shadowsocks.json" "${SHADOWSOCKS_CONF}"

	# читаем данные и Производим замену в библиотеке ndm основных значения интерфейсов
	shadowsocks_read_config && 	ndm_interface_change "$(get_ssr_entware_interface)" "shadowsocks"
}
# ------------------------------------------------------------------------------------------
#
#	Чистим таблицу правил iptables для shadowsocks подключений
#
# ------------------------------------------------------------------------------------------
cmd_shadowsocks_iptable_flush() {
	if [ -f /opt/apps/kvas/bin/libs/ndm ]; then
		ready "Удаление правил iptables для shadowsocks завершено"
		ip4_firewall_ssr_prune &>/dev/null
		[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
	fi

}
# ------------------------------------------------------------------------------------------
#
#	Переустанавливаем правила в itables для shadowsocks клиента
#
# ------------------------------------------------------------------------------------------
cmd_shadowsocks_iptable_reset() {

	ready "Переустановка iptables для shadowsocks завершена"
	if [ -f /opt/apps/kvas/bin/libs/ndm ]; then
		local_ip=$(get_router_ip)
		inface=$(get_inface_by_ip "${local_ip}")
		proxy_port=$(get_config_value SSR_DNS_PORT)
		recreate_ip4tables &>/dev/null
		recreate_ssr_rules &>/dev/null

	else
		exit 1
	fi
	[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
}
# ------------------------------------------------------------------------------------------
#
#	Отключаем shadowsocks клиента
#
# ------------------------------------------------------------------------------------------
shadowsocks_off() {
	ready "Интерфейс shadowsocks отключен "
	#	сохраняем файл конфигурации shadowsocks
	/opt/etc/init.d/S22shadowsocks stop &> /dev/null
	mv -f "${SHADOWSOCKS_CONF}" "${SHADOWSOCKS_CONF}.kvas" &> /dev/null
	rm -f "/opt/etc/ndm/netfilter.d/100-proxy-redirect"
	cmd_shadowsocks_iptable_flush &> /dev/null
	[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
}

# ------------------------------------------------------------------------------------------
#
#	Меняем текущий локальный порт на shadowsocks на новый
#
#	$1 - новый порт
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
cmd_shadowsocks_local_port_change() {
	if cmd_vpn_status | grep -iq 'shadowsocks' ; then

		port_new=${1}; cmd=${2:-restart}
		if [ -n "${port_new}" ]	; then

			ready "Замена порта на ${port_new} в shadowsocks завершена"

#			sed -i "s/\(--to-port\).*/\1 ${port_new}/g" "/opt/etc/ndm/netfilter.d/100-proxy-redirect"
			sed -i "s/\(local_port\":\).*/\1 ${port_new}/g" "${SHADOWSOCKS_CONF}"

			set_config_value SSR_DNS_PORT "${port_new}"
			cmd_shadowsocks_iptable_reset &> /dev/null

			[ "${cmd}" = restart ] && /opt/etc/init.d/S22shadowsocks restart &> /dev/null
			[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
		else
			ready "Текущий номер порта shadowsocks соединения:"
			when_ok "$(get_config_value SSR_DNS_PORT)"
		fi
	else
		answer=''
		error "shadowsocks клиент не выбран в настройках"
		read_ynq "Включить его вместо текущего соединения" answer
		[ "${answer}" = y ] && shadowsocks_on; cmd_shadowsocks_local_port_change "${port_new}"
	fi
}



# ------------------------------------------------------------------------------------------
#
#	Отключаем shadowsocks клиента
#
# ------------------------------------------------------------------------------------------
shadowsocks_on() {

	local_ip=$(get_router_ip)
	inface=$(get_inface_by_ip "${local_ip}")

	#	настройка файла 100-proxy-redirect
	cp "/opt/apps/${APP_NAME}/etc/ndm/netfilter.d/100-proxy-redirect" "/opt/etc/ndm/netfilter.d/100-proxy-redirect"
	chmod +x "/opt/etc/ndm/netfilter.d/100-proxy-redirect"

	ndm_interface_change "$(get_ssr_entware_interface)" "shadowsocks"

	cmd_shadowsocks_iptable_reset  &> /dev/null
	#   настройка S22shadowsocks конфигурации
	if [ -f "${SHADOWSOCKS_CONF}.kvas" ] ; then
	   	ready "Используем данные"
		cp "${SHADOWSOCKS_CONF}.kvas" "${SHADOWSOCKS_CONF}"
		when_alert "ИЗ АРХИВА"
	elif [ -f "${SHADOWSOCKS_CONF}" ] ; then
		if grep -qE '""|@' "${SHADOWSOCKS_CONF}" || grep -qE '127.0.0.1|barfoo!' "${SHADOWSOCKS_CONF}"; then
			print_line
			shadowsocks_read_data
		fi
	else
		print_line
		shadowsocks_read_data
	fi


	# меняем данные в файлах shadowsocks
	sed -i 's/ss-local/ss-redir/g' "/opt/etc/init.d/S22shadowsocks"
	#	включаем shadowsocks службу

	ready "Интерфейс shadowsocks подключен "
	/opt/etc/init.d/S22shadowsocks restart &> /dev/null
	/opt/etc/init.d/S22shadowsocks status &> /dev/null
	if [ $? = 0 ]; then
		when_ok "УСПЕШНО"
	else
		when_bad "ОШИБКА"
		error "Возникла ошибка при подключении shadowsocks интерфейса!"
		error "Проверьте доступность сервера и настройки клиента!"
		exit 1
	fi
}


# ------------------------------------------------------------------------------------------
#
#	Получаем нумерованный список с именами интерфейсов
#
# ------------------------------------------------------------------------------------------
update_interface_name_list() {

	warning "Производим сканирование интерфейсов!"
	#warning "Это займет время."
	warning "Сохраняйте терпение и спокойствие!"
	print_line
	# если нет файла по отлавливанию хука
	if ! [ -f "${HOOK_INFACE_FILE}" ]; then
		#	создаем файл
		cat <<EOF >"${HOOK_INFACE_FILE}"
#!/bin/sh
if ! [ -f "${INFACE_NAMES_FILE}" ]; then touch "${INFACE_NAMES_FILE}"; fi

if [ -z "\$(grep "\${id}" "${INFACE_NAMES_FILE}")" ]; then
	echo "\${id}|\${system_name}" >> "${INFACE_NAMES_FILE}"
fi
exit 0
EOF
		chmod +x "${HOOK_INFACE_FILE}"
	fi
	# очищаем файл с именами интерфейсов
	echo "shadowsocks|$(get_ssr_entware_interface)|shadowsocks" > "${INFACE_NAMES_FILE}"
	# обозначаем список типов обрабатываемых VPN интерфейсов
	types_inface='"OpenVPN","Wireguard","IKE","SSTP","PPPOE","L2TP"'
#	архивный вариант с выключенными интерфейсами сотовых операторов
#	types_inface='"OpenVPN","Wireguard","IKE","SSTP","PPPOE","L2TP","CdcEthernet","UsbLte"'
	# получаем список ID интерфейсов в наличии на роутере через пробел
	inface_list=$(
		curl -s "${INFACE_REQUEST}" \
			| jq -r '.[] | select([.type]| inside(['"${types_inface}"'])) | select(.defaultgw!=true) | .id' \
			| tr '\n' ' ' \
	)
	# проходимся по каждому интерфейсу
	# ВНИМАНИЕ! inface_list - все маленькими буквами!!!
	for inface_cli in ${inface_list}; do
#		переподключаем текущее соединение
		reset_connection "${inface_cli}"
		# получаем описание интерфейса
		description=$(get_value_interface_field "${inface_cli}" description | sed 's|\/|\\/|g')
		# вставляем описание в файл /opt/etc/inface_equals
		[ -n "${description}" ] && \
			sed -i 's/\('"${inface_cli}"'.*\)/\1|'"${description}"'/' "${INFACE_NAMES_FILE}"
	done
	rm -f "${HOOK_INFACE_FILE}"
}
# ------------------------------------------------------------------------------------------
#
#	Получаем нумерованный список с именами интерфейсов для командой строки
#
# ------------------------------------------------------------------------------------------
cmd_scan_interface_list() {
	update_interface_name_list
	warning "Сканирование интерфейсов завершено:";
	print_line
	show_vpn_list
}

# ------------------------------------------------------------------------------------------
#
#	Получаем название интерфейса по номеру в списке в файле INFACE_NAMES_FILE
# 	$1 - номер строки в файле
#	$2 - тип возвращаемых данных
#		cli - id интерфейсов в CLI
#		entware (по умолчанию) - id интерфейсов в entware
#
# ------------------------------------------------------------------------------------------
get_vpn_interface_by_num() {
	number="${1}"
	type_data=${2:-entware}

	if [ "${type_data}" = entware ]; then _type=2; else _type=1; fi
	cat < "${INFACE_NAMES_FILE}" | sed -n "${number}"'p' | cut -d'|' -f"${_type}"
}

# ------------------------------------------------------------------------------------------
#
#	Получаем название текущего интерфейса
# 	$1 - тип интерфейса допустимы entware, cli, cli_desc
#
# ------------------------------------------------------------------------------------------
get_current_vpn_interface() {
	type="${1}"
	if [ -f "/opt/etc/ndm/netfilter.d/100-proxy-redirect" ]; then
		inface='shadowsocks'
	else
		case "${type}" in
			entware) col=2 ;;
			cli) col=1 ;;
			cli_desc) col=3 ;;
			*) col=1 ;;
		esac
		inface_entware=$(get_config_value "INFACE_ENT")
		inface=$(grep "${inface_entware}" "${INFACE_NAMES_FILE}" | cut -d'|' -f"${col}")
	fi
	echo "${inface}"
}

# ------------------------------------------------------------------------------------------
#
#	Переключаем интерфейс клиента
#	$1 - id интерфейса в cli
#
# ------------------------------------------------------------------------------------------
is_vpn_interface_connected() {
	cli_inface="${1}"
	if [ "${cli_inface}" = shadowsocks ]; then
		/opt/etc/init.d/S22shadowsocks status | grep -q 'alive' &> /dev/null
		if [ $? = 0 ]; then connected="on"; else connected="off"; fi
	else
		status=$(get_value_interface_field "${cli_inface}" connected)
		if [ "${status}" = 'yes' ]; then connected="on"; else connected="off"; fi
	fi
	echo "${connected}"
}
# ------------------------------------------------------------------------------------------
#
#	Выводим список текущих интерфейсов с номерами по порядку и данными об их доступности
#
# ------------------------------------------------------------------------------------------
show_vpn_list() {

	inface_entware=$(get_current_vpn_interface 'entware')
	num=0;

	while read -r line || [ -n "${line}" ]; do

		num=$((num + 1))
		is_current_vpn=$(echo "${line}" | grep -i "${inface_entware}")
		cli_inface_desc=$(echo "${line}" | cut -d"|" -f3)
		cli_inface=$(echo "${line}" | cut -d"|" -f1)
		mess="${num}. Интерфейс ${cli_inface_desc}"
		sleep 1
		connected=$(is_vpn_interface_connected "${cli_inface}")

		if [ -n "${is_current_vpn}" ]; then
			mess="${BLUE}${mess} [текущий]${NOCL}"
		fi

		ready "${mess}"
		if [ "${connected}" = "on" ]; then when_ok "В СЕТИ"; else when_bad "ОТКЛЮЧЕН"; fi
	done <${INFACE_NAMES_FILE}
}
# ------------------------------------------------------------------------------------------
#
#	Переключаем интерфейс клиента
#   $1  - ask - делаем запросы на ввод данные ,
#   	  no - список интерфейсов не обновляем
#
# ------------------------------------------------------------------------------------------
cmd_interface_change() {

	answer="${1}"
	is_install_stage="${2:-no}"

	if [ -f "${INFACE_NAMES_FILE}" ]; then
		if [ "${answer}" = ask ] ; then
			read_ynq "Обновить список интерфейсов" answer
			print_line
			if [ "${answer}" = y ]; then
				update_interface_name_list
			fi
		fi
	else
		update_interface_name_list
	fi

	warning "Выберите VPN интерфейс для работы пакета"
	print_line
#	Отображаем список текущих интерфейсов с номерами по порядку и данными об их доступности
	show_vpn_list

	total=$(cat < "${INFACE_NAMES_FILE}" | wc -l)
	while true; do
		print_line
		ready "${BLUE}Выберите номер варианта VPN соединения [1-${total}]:${NOCL}"
		read -r num_vpn_inface
		if ! echo "${num_vpn_inface}" | grep -qE "[1-${total}]"; then
			error "Введите цифру от 1 до ${total}."
		else
#			Меняем интерфейс в файле ndm
			inface_entware=$(get_vpn_interface_by_num "${num_vpn_inface}")
			cli_inface=$(echo "${INFACE_NAMES_FILE}" | grep "${inface_entware}" | cut -d"|" -f1)
			ndm_interface_change "${inface_entware}" "${cli_inface}"

			if [[ "${inface_entware}" =~ ${SSR_ENTWARE_TEMPL} ]]; then
				vpn_off &> /dev/null
				shadowsocks_backup
				shadowsocks_on
			else
				shadowsocks_off &> /dev/null
				vpn_on "${inface_entware}"
			fi
			[ "${is_install_stage}" = no ] && cmd_kvas_init
			break
		fi
	done

}



# ------------------------------------------------------------------------------------------
#
#	Обновляем маршруты и таблицы ipset...
#
# ------------------------------------------------------------------------------------------
cmd_update_list() {
	ready "Обновляем маршруты и таблицы ipset..."
	"${UPDATE_BIN_FILE}" miss_ads &> /dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
}
# ------------------------------------------------------------------------------------------
#
#	Меняем текущий порт dnscrypt_proxy2 на новый
#
#	$1 - новый номер порта
#	$2 - команда перегрузки сервиса dnsmasq
#		restart (по умолчанию) - перегружаем dnsmasq
#		norestart - не перегружаем сервис
#
# ------------------------------------------------------------------------------------------
dns_crypt_port_change() {

	port_new=${1}; cmd=${2:-restart}
	ready "Замена локального порта на ${port_new} в dnscrypt_proxy2 завершена"

	set_config_value DNS_CRYPT_PORT "${port_new}"
	sed -i "s/\(^listen_addresses.=.\).*$/\1['[::]:${port_new}']/g" "${DNSCRYPT_CONFIG}" &> /dev/null
	sed -i "s/\(@.*\)\(:[0-9]\{2,6\}\)/\1:${port_new} /g" '/opt/apps/kvas/bin/main/ipset' &> /dev/null

	server_crypt_0="echo \"server=\/:.*\${host}:\/${LOCALHOST_IP}#${port_new}\" >> \/opt\/etc\/kvas.dnsmasq"
	server_crypt_1="echo \"server=\/\${host}\/${LOCALHOST_IP}#${port_new}\" >> \/opt\/etc\/kvas.dnsmasq"
	sed -i '/server/d' '/opt/apps/kvas/bin/main/dnsmasq' &> /dev/null
	sed -i "s/\(echo \"ipset=\/:.*\)/\1\n\t${server_crypt_0}/" '/opt/apps/kvas/bin/main/dnsmasq' &> /dev/null
	sed -i "s/\(echo \"ipset=\/\$.*\)/\1\n\t${server_crypt_1}/" '/opt/apps/kvas/bin/main/dnsmasq' &> /dev/null

	if [ "${cmd}" = restart ]; then
		cmd_dnsmasq_dns_change "${LOCALHOST_IP}#${port_new}" restart &> /dev/null
		if ! [ -f /opt/etc/init.d/S09dnscrypt-proxy2 ]; then
			if [ -f "${KVAS_BACKUP_PATH}/S09dnscrypt-proxy2" ]; then
				cp "${KVAS_BACKUP_PATH}/S09dnscrypt-proxy2" /opt/etc/init.d/S09dnscrypt-proxy2
			else
				error "Нарушена работа пакета, файл /opt/etc/init.d/S09dnscrypt-proxy2 отсутствует"
				exit 1
			fi
		fi
		/opt/etc/init.d/S09dnscrypt-proxy2 restart &> /dev/null
	else
		cmd_dnsmasq_dns_change "${LOCALHOST_IP}#${port_new}" &> /dev/null
	fi

	[ $? = 0 ] && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}


# ------------------------------------------------------------------------------------------
#
# 	Пересоздаем таблицу ipset для dnsmasq и перезапускаем сервис
# 	В том числе и обрабатываем dns_crypt в случае, если он запущен
#
# ------------------------------------------------------------------------------------------
refresh_dnsmasq_ipset_table(){

		ready "${prefix}Заполняем dnsmasq таблицу данными из списка разблокировки."
		if /opt/apps/kvas/bin/main/dnsmasq  ; then #&>/dev/null
			when_ok "ГОТОВО"
		else
			if /opt/apps/kvas/bin/main/dnsmasq  ; then
				when_ok "ГОТОВО"
			else
				when_bad "ОШИБКА"
			fi
		fi
		ready "${prefix}Перезапускаем сервис dnsmasq"
		/opt/etc/init.d/S56dnsmasq restart &>/dev/null
		[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

		if get_dns_crypt_status | grep -q on ; then
			ready "${prefix}Перезапускаем сервис dns_crypt"
			dns_crypt_install '' &>/dev/null
			[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
		fi
}


# ------------------------------------------------------------------------------------------
#
#	 Статус dnscrypt_proxy2
#	 on - включен
#	 off - выключен
#
# ------------------------------------------------------------------------------------------
get_dns_crypt_status() {
	crypt_port=$(get_config_value DNS_CRYPT_PORT)
	if [ -f '/opt/sbin/dnscrypt-proxy' ] &&
		cat < '/opt/apps/kvas/bin/main/ipset' | grep '@' | grep -q "${crypt_port}" &&
		cat < '/opt/apps/kvas/bin/main/dnsmasq' | grep -q 'server' &&
		netstat -tulnp 2> /dev/null | grep -q dnscrypt; then

		echo on
	else
		echo off
	fi

}
# ------------------------------------------------------------------------------------------
#
#	 Устанавливаем с нуля dnscrypt_proxy2
#
# ------------------------------------------------------------------------------------------
dns_crypt_install() {
	is_install_stage="${1}"
#	В случае наличия архива файла запуска сервиса dnscrypt_proxy2
	if [ -f /opt/etc/init.d/K09dnscrypt-proxy2 ]; then
		warning "Обнаружен архив файла S09dnscrypt-proxy2."
		ready "Восстанавливаем S09dnscrypt-proxy2 из архива..."
#		реанимируем его из архива
		cp /opt/etc/init.d/K09dnscrypt-proxy2 /opt/etc/init.d/S09dnscrypt-proxy2 1> /dev/null 2> "${ERROR_LOG_FILE}"
		ready_status "${?}" "Ошибка при восстановлении S09dnscrypt-proxy2 из архива"
	else
		# Если запуск функции был не при установке пакета Квас
			if [ -z "${is_install_stage}" ]; then
		#		при его отсутствии - устанавливаем пакет
				if ! [ -f /opt/etc/init.d/S09dnscrypt-proxy2 ]; then
					ready "Устанавливаем пакет dnscrypt-proxy2..."
					opkg remove dnscrypt-proxy2 1> /dev/null 2> "${ERROR_LOG_FILE}"
					opkg install dnscrypt-proxy2 1> /dev/null 2> "${ERROR_LOG_FILE}"
					when_error "${?}" "Ошибка при установке пакета dnsmasq"
				fi
			else
				if ! [ -f /opt/etc/init.d/S09dnscrypt-proxy2 ]; then
	#				Если вызвана функция из postinst
					error "Пакет dnscrypt-proxy2 был установлен с ошибками или поврежден!"
					error "Файл запуска пакета /opt/etc/init.d/S09dnscrypt-proxy2 отсутствует!"
					warning "Удалите Квас и затем переустановите пакет dnscrypt-proxy2"
					exit 1
				fi
			fi


	fi
#	Если dnscrypt_proxy2 запущен, то останавливаем его,
#	так как необходимо его предварительно настроить
	if /opt/etc/init.d/S09dnscrypt-proxy2 status | grep -q alive ; then
		ready "Останавливаем службу dnscrypt-proxy2..."
		/opt/etc/init.d/S09dnscrypt-proxy2 stop 1> /dev/null 2> "${ERROR_LOG_FILE}"
		ready_status "${?}" "Проблема при остановке службы dnscrypt-proxy2"
	fi

#	архивируем предыдущие настройки
	if [ -f '/opt/etc/dnscrypt-proxy.toml' ]; then
		warning "Файл конфигурации dnscrypt-proxy2 сохраняем"
		cp /opt/etc/dnscrypt-proxy.toml ${KVAS_BACKUP_PATH}/dnscrypt-proxy.toml
		warning "под именем ${KVAS_BACKUP_PATH}/dnscrypt-proxy.toml"
	elif [ -f "${KVAS_BACKUP_PATH}/dnscrypt-proxy.toml" ]; then
		warning "Обнаружен файл конфигурации dnscrypt-proxy2 "
		cp "${KVAS_BACKUP_PATH}/dnscrypt-proxy.toml" /opt/etc/dnscrypt-proxy.toml
		warning "Восстанавливаем предыдущие настройки."
	fi

#	Настраиваем сервис
	ready "Настраиваем dnscrypt-proxy2..."
	cmd_dns_crypt_on 1> /dev/null 2> "${ERROR_LOG_FILE}"
	ready_status "${?}" "Проблема при активации шифрования DNS трафика"
}
# ------------------------------------------------------------------------------------------
#
#	 Включаем работу блока шифрования dns при помощи dnscrypt_proxy2
#
# ------------------------------------------------------------------------------------------
cmd_dns_crypt_on() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		crypt_port=$(get_config_value DNS_CRYPT_PORT)
		if [ "$(get_dns_crypt_status)" = on ]; then
			ready "Шифрование DNS уже";	when_ok "ПОДКЛЮЧЕНО"
		else
			dns_crypt_port=$(get_config_value DNS_CRYPT_PORT)
			dns_cache_enabled=$(get_config_value DNS_CACHE_ENABLED)
			ready "Шифрование DNS"
			{
				sed -i "s/\(^cache.=.\).*$/\1${dns_cache_enabled}/g" '/opt/etc/dnscrypt-proxy.toml'
				sed -i "s/\(^require_dnssec.=.\).*$/\1true/g" '/opt/etc/dnscrypt-proxy.toml'

				sed -i "/proxy-dnssec/d" /opt/etc/dnsmasq.conf
				echo "proxy-dnssec" >> /opt/etc/dnsmasq.conf
				dns_crypt_port_change "${dns_crypt_port}" restart

			} 1> /dev/null 2> "${ERROR_LOG_FILE}"
			ready_status "${?}" "Произошла непредвиденная ошибка." "ПОДКЛЮЧЕНО"
		fi
	}
}
# ------------------------------------------------------------------------------------------
#
#	 ВЫключаем работу блока шифрования dns при помощи dnscrypt_proxy2
#
# ------------------------------------------------------------------------------------------
cmd_dns_crypt_off() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		ready "Шифрование DNS"
		{
			crypt_port=$(get_config_value DNS_CRYPT_PORT)
			static_dns=$(get_config_value DNS_STATIC_1)
			sed -i "s/\(@.*\)\(:[0-9]\{2,6\}\)/@localhost/g" '/opt/apps/kvas/bin/main/ipset'
			sed -i "/proxy-dnssec/d" /opt/etc/dnsmasq.conf
			sed -i "s/\(^server=\)${LOCALHOST_IP}#${crypt_port}/\1${static_dns}/" /opt/etc/dnsmasq.conf
			sed -i '/server/d' '/opt/apps/kvas/bin/main/dnsmasq'

			rm '/opt/etc/kvas.dnsmasq'
			_dns=$(cat < "${DNSMASQ_CONFIG}" | sed -n 's/^server=\(.*\)$/\1/p')
			set_config_value DNS_DEFAULT "${_dns}#${MAIN_DNS_PORT}"
			set_config_value DNS_CRYPT_PORT "${crypt_port}"

			/opt/etc/init.d/S09dnscrypt-proxy2 stop
			cmd_kvas_init

		} 1> /dev/null 2> "${ERROR_LOG_FILE}"
		ready_status "${?}" "Произошла непредвиденная ошибка." "ОТКЛЮЧЕНО"
	}
}
# ------------------------------------------------------------------------------------------
#
#	 Выводим статус блока шифрования dns при помощи dnscrypt_proxy2
#
# ------------------------------------------------------------------------------------------
cmd_dns_crypt_status_show() {
	exit_when_adguard_on status; [ "${status}" = 0 ] && {

		ready "Шифрование DNS"
		if [ "$(get_dns_crypt_status)" = on ]; then
			when_ok "ПОДКЛЮЧЕНО"
		else
			when_bad "ОТКЛЮЧЕНО"
		fi
	}

}


# ------------------------------------------------------------------------------------------
#
#	Тестируем хост на доступность
#	$1 - доменное имя
#	$2 - команда для возврата:
#		ip - возвращает ip вместо 1
#
# ------------------------------------------------------------------------------------------
test_host() {

	ret=0
	if echo "${1}" | grep -q '\.' ; then
		dns=$(get_config_value DNS_DEFAULT )
		ips="$(kdig "${1}" +short "@${dns}" 2> /dev/null)"
		if [ -z "${ips}" ]; then
			dns=$(get_config_value DNS_STATIC_1)
			ips=$(kdig "${1}" +short "@${dns}" 2> /dev/null)

			if [ -z "${ips}" ]; then
				dns=$(get_config_value DNS_STATIC_2);
				ips=$(kdig "${1}" +short "@${dns}" 2> /dev/null)
				[ -n "${ips}" ] && set_config_value DNS_DEFAULT "${dns}"
			else
				set_config_value DNS_DEFAULT "${dns}"
			fi
		fi
		if [ -n "${2}" ] && [ "${2}" = ip ]; then
			ret=${ips}
		else
			if [ -n "$( echo "${ips}" | head -1 2> /dev/null )" ]; then ret=1; fi
		fi
	fi
	echo "${ret}"

}
host_add() {
	_host="${1}"
	clear_host=$(echo "${host}" | sed 's/\*//')

	ready "Добавляем ${YELLOW}${_host}${NOCL} в список разблокировки..."
	echo "${_host}" >> "${UNBLOCK_LIST_FILE}"
#	если включен блокировщик рекламы
	if cmd_ads_status | grep -q ВКЛЮЧЕН ; then
		ads_del_white_list_hosts &> /dev/null
	fi
	cmd_kvas_init  &> /dev/null
	[ $? = 0 ] && when_ok "ДОБАВЛЕН" || when_bad "НЕ ДОБАВЛЕН"
}
# ------------------------------------------------------------------------------------------
#
#	Добавляем в белый список одно доменное имя, точнее список его IP адресов
#	$1 - доменное имя, для которого необходимо получить IP
#
# ------------------------------------------------------------------------------------------
cmd_add_one_host() {
	host=$(echo "${1}" | sed 's|http[s]\{,1\}://||;')
	clear_host=$(echo "${host}" | sed 's/\*//')
	ip_filter='[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
	#	формальная проверка на наличие точки в имени домена
	if echo "${host}" | grep -q '\.' ; then
		if echo "${clear_host}" | grep -qE "${ip_filter}*" ; then
			if echo "${clear_host}" | grep -qE "^${ip_filter}/[0-9]{1,2}$|^${ip_filter}$|^${ip_filter}-${ip_filter}$"; then
				host_add "${host}"
			else
				echo -e "${RED}Введенный IP адрес или диапазон IP-адресов имеет некорректный формат.${NOCL}"
			fi
		else
			if cat < "${UNBLOCK_LIST_FILE}" | grep -qe "${clear_host}"; then
				if [ -z "${2}" ]; then
					warning "Такой домен уже есть в списке разблокировки!"
					warning "Производим замену ${clear_host} на ${host}"
					print_line
					sed -i "/^${clear_host}$/d" "${UNBLOCK_LIST_FILE}"
					host_add "${host}"
				else
					echo 1
				fi
			else
				if [ -z "${2}" ]; then
					host_add "${host}"
				else
					echo +
				fi
			fi
		fi
	else
		if [ -z "${2}" ]; then
			error "Некорректно указано имя домена - ${1}."
		else
			echo 0
		fi
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Удаляем из белого списка одно доменное имя, точнее список его IP адресов
#	$1 - доменное имя для удаления
#
# ------------------------------------------------------------------------------------------
cmd_del_one_host() {
	host_="${1}"
	if cat < "${UNBLOCK_LIST_FILE}" | grep -qe "${host_}$" ; then
		ready "Удаляем ${YELLOW}${host_}${NOCL} из списка разблокировки..."
		sed -i "/${host_////\\/}/d" "${UNBLOCK_LIST_FILE}"
		cmd_kvas_init  &> /dev/null
		[ $? = 0 ] && when_ok "УДАЛЕН" || when_bad "НЕ УДАЛЕН"
	else
		error "Такая запись отсутствует в списке разблокировки!"
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Очищаем полностью белый список
#
# ------------------------------------------------------------------------------------------
cmd_clear_list() {

	if [ -f "${UNBLOCK_LIST_FILE}" ]; then
		if [ "$(rec_in_file "${UNBLOCK_LIST_FILE}")" = '0' ]; then
			error "Список разблокировки не содержит записей!"
		else
			while true; do
				ready "Список разблокировки будет полностью очищен. Уверены?" && read -r yn
				case ${yn} in
				[Yy]*)
					print_line
					ready "Очищаем список разблокировки ..."
					mv -f "${UNBLOCK_LIST_FILE}" "${KVAS_BACKUP_LIST_FILE}"
					touch "${UNBLOCK_LIST_FILE}"
					cmd_kvas_init  &> /dev/null
					[ $? = 0 ] && when_ok "ОЧИЩЕН" || when_bad "ОШИБКА"
					print_line
					warning "Предыдущий список разблокировки был сохранен в файл ${KVAS_BACKUP_LIST_FILE}"
					break
					;;
				[Nn]*)
					break
					;;
				*)
					please_repeat
					;;
				esac
			done
		fi
	else
		error "Списочный файл не существует!"
	fi
}

# ------------------------------------------------------------------------------------------
#
#	Считаем число строк/записей в переданной переменной
#
# ------------------------------------------------------------------------------------------
rec_in_var() {
	echo -e "${1}" | sed '/^$/d' | wc -l
}


# ------------------------------------------------------------------------------------------
#
#	Импортируем (вносим) список доменов в "белый список"
#
#	$1 - имя файла со списком доменных имен, допускается использование # для комментариев
#		 одно имя - одна строка в списочном файле
#
# ------------------------------------------------------------------------------------------

cmd_import_hosts() {
	host_list="${1}"
	if [ -z "${host_list}" ]; then
		error "Не задано имя файла для импорта."
		error "Укажите его вторым аргументом при запуске!"
	else
		if ! [ -f "${host_list}" ]; then
			error "Списочный файл ${host_list} не существует."
			error "Проверьте верность написания пути и его имени."
		else
			ready "Импортируем хосты в список разблокировки и обновляем маршруты..."
			clear_file_content "${host_list}"

			clear_file_content "${UNBLOCK_LIST_FILE}"

			hosts_to_add_ubl=''
			hosts_repeated_ubl=''
			hosts_not_added=''

			while read -r line || [ -n "${line}" ]; do
				# удаляем из строки комментарии - все что встречается после символа # и сам символ
				host=$(echo "${line}" | sed 's/#.*$//g' | tr -s ' ')
				#  пропускаем пустые строки и строки с комментариями
				[ -z "${host}" ] && continue
				#  пропускаем строки с комментариями
				[ "${host:0:1}" = "#" ] && continue

				case "$(cmd_add_one_host "${host}" "test")" in
				0) hosts_not_added="${hosts_not_added}${host}\n" ;;
				1) hosts_repeated_bl="${hosts_repeated_bl}${host}\n" ;;
				+) hosts_to_add_ubl="${hosts_to_add_ubl}${host}\n" ;;
				*) ;;
				esac
			done < "${host_list}"

			#     добавляем хосты в файл списочный
			_hosts_to_add_ubl=$(echo -e "${hosts_to_add_ubl}" | sed '/^$/d; /^[-+.]/!s/\(.*\)/\1/')
			echo -e "${_hosts_to_add_ubl}" >> "${UNBLOCK_LIST_FILE}"

			#	если включен блокировщик рекламы
			if cmd_ads_status | grep -q ВКЛЮЧЕН ; then
				ads_del_white_list_hosts &> /dev/null
			fi
			cmd_kvas_init   &> /dev/null
			[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

			num_not_added=$(rec_in_var "${hosts_not_added}")
			num_repeated_ubl=$(rec_in_var "${hosts_repeated_ubl}")
			num_to_add_ubl=$(rec_in_var "${hosts_to_add_ubl}")

			num_errors=$((num_not_added + num_repeated_ubl))
			tab="    "
			print_line
			if [ "${num_to_add_ubl}" -eq 0 ]; then
				warning "Новых записей добавлено не было!"
			else
				warning "В список разблокировки было добавлено ${YELLOW}${num_to_add_ubl}${GREEN} записей:"
				print_line
				if [ "${num_to_add_ubl}" -gt 0 ]; then
					warning "${tab}Список разблокировки ${YELLOW}${num_to_add_ubl}${GREEN} записей:"
					print_line
					echo -e "${hosts_to_add_ubl}" | sed 's/^$//; /^[-]/!s/\(.*\)/'"${tab}${tab}"'\1/g'
				fi
			fi
			if [ "${num_errors}" -gt 0 ]; then
				echo
				error "В ходе импорта возникли ошибки ${YELLOW}${num_errors}${RED} шт.:"
				print_line
				if [ "${num_not_added}" -gt 0 ]; then
					error "${tab}Проблем в написании или недоступности доменов выявлено ${YELLOW}${num_not_added}${RED} шт."
					print_line
					echo -e "${hosts_not_added}" | sed 's/^$/'"$(print_line)"'/; /^[-]/!s/\(.*\)/'"${tab}${tab}"'\1/g'
				fi
				if [ "${num_repeated_ubl}" -gt 0 ]; then
					error "${tab}Домены ниже уже присутствуют в списке разблокировки [${YELLOW}${num_repeated_ubl}${RED} шт.]"
					print_line
					echo -e "${hosts_repeated_ubl}" | sed 's/^$/'"$(print_line)"'/; /^[-]/!s/\(.*\)/'"${tab}${tab}"'\1/g'
				fi
			fi
		fi
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Экспортируем (сохраняем) список доменов в другой файл
#	$1 - имя файла архива
#
# ------------------------------------------------------------------------------------------
cmd_export_hosts() {
	HOSTS_LIST=$(cat < "${UNBLOCK_LIST_FILE}" | sed 's/\(^.*\)#.*$/\1/g' | grep -v '#' | tr -s '\n')
	backup_name=${1}
	if [ -z "${backup_name}" ]; then
		error "Так как не задано имя файла для экспорта, то"
		error "Сохраняем архив в файл ${KVAS_BACKUP_LIST_FILE}"
	else
		mkdir -p "$(dirname "${backup_name}")" && touch "${backup_name}" &> /dev/null
	fi
	ready "Сохраняем записи в файл ${YELLOW}${backup_name}${GREEN}..."
	echo "${HOSTS_LIST}" > "${backup_name}"
	[ $? = 0 ] && when_ok "СОХРАНЕНЫ" || when_bad "ОШИБКА"
}
# ------------------------------------------------------------------------------------------
#
#	Отображаем БС
#
# ------------------------------------------------------------------------------------------
print_host_list(){
	warning "Список разблокировки содержит ${YELLOW}${num_plus}${GREEN} записей:"
	print_line
	clear_content "${UNBLOCK_LIST_FILE}"
}

cmd_show_list() {

	if [ -f "${UNBLOCK_LIST_FILE}" ]; then
		num_plus=$(rec_in_file "${UNBLOCK_LIST_FILE}")
		if [ "${num_plus}" -eq 0 ]; then
			echo -e "${RED}Список разблокировки пуст!${NOCL}"
#			Если список хостов пуст, то проверяем есть ли архивная копия
			if [ -f "${KVAS_BACKUP_LIST_FILE}" ] ; then
				print_line
				warning "Обнаружена архивная копия списка разблокировки!"
				answer=''; read_ynq "Восстановить данные из архива или нет [Y/N]?" answer
				if [ "${answer}" = y ]; then
					cp "${KVAS_BACKUP_LIST_FILE}" "${UNBLOCK_LIST_FILE}"
					warning "Список разблокировки восстановлен из архивной копии."
					print_line
					print_host_list
				else
					print_line
					warning "Пожалуйста, добавьте данные в список при помощи 'kvas add имя_домена'"
				fi
			else
				print_line
				warning "Пожалуйста, добавьте в него данные при помощи 'kvas add имя_домена'"
			fi
		else
			print_host_list
		fi
	else
#		Если список хостов не существует, то проверяем, есть ли архивная копия
		if [ -f "${KVAS_BACKUP_LIST_FILE}" ] ; then
			warning "Обнаружена архивная копия списка разблокировки!"
				answer=''; read_ynq "Восстановить данные из архива (Y) или нет (N)?" answer
				if [ "${answer}" = y ]; then
					cp "${KVAS_BACKUP_LIST_FILE}" "${UNBLOCK_LIST_FILE}"
					warning "Список разблокировки восстановлен из архивной копии."
					print_line
					print_host_list
				fi
		else
			error "Списка разблокировки не существует."
			warning "Пожалуйста, добавьте в него данные при помощи 'kvas add имя_домена'"
		fi
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Устанавливаем частоту обновления списка ip адресов в кроне
#
#	$1 - Период обновления в формате
#		 2h - обновляем каждые два часа
#		 2m - каждые две минуты"
#
# ------------------------------------------------------------------------------------------
get_time() {
	cat < "${CRONTAB_FILE}" | grep -E "root ${UPDATE_BIN_FILE} update" | cut -d' ' -f"${1}" | cut -d'/' -f2 | sed 's/[a-zA-Z\*]//g'
}
get_period_update() {
	mm=$(get_time 1)
	hh=$(get_time 2)
	dd=$(get_time 3)
	ww=$(get_time 4)
	nn=$(get_time 5)
	echo -en "${YELLOW}Периодичность обновления "
	if [ -n "${mm}" ] && [ "${mm}" -gt 0 ]; then
		echo -e "каждые ${mm} мин.${NOCL}"
	elif [ -n "${hh}" ] && [ "${hh}" -gt 0 ]; then
		echo -e "каждые ${hh} ч. ${NOCL}"
	elif [ -n "${dd}" ] && [ "${dd}" -gt 0 ]; then
		echo -e "каждые ${dd} дн. ${NOCL}"
	elif [ -n "${ww}" ] && [ "${ww}" -gt 0 ]; then
		echo -e "каждые ${ww} нед. ${NOCL}"
	elif [ -n "${nn}" ] && [ "${nn}" -gt 0 ]; then
		echo -e "каждые ${nn} мес. ${NOCL}"
	else
		error "не задана!"
		echo "Поэтому, устанавливаем его по умолчанию."
		cmd_set_period_update "12h"
	fi
}
# ------------------------------------------------------------------------------------------
#
#	Устанавливаем частоту обновления списка ip адресов в кроне
#
#	$1 - Период обновления в формате
#		 2h - обновляем каждые два часа
#		 2m - каждые две минуты"
#
# ------------------------------------------------------------------------------------------
get_period() {
	echo "${1}" | grep "${2}" | cut -d"${2}" -f1
}
cmd_set_period_update() {
	if [ -z "${1}" ]; then
		#		если аргумент не задан, то просто
		#		отображаем заданный период обновления
		get_period_update
	elif ! echo "${1}" | grep -q '[m,h,d,w,M]' ; then
		error "Указан не верный формат периода."
		print_line
		warning "Период должно указать в форматах: m,h,d,w,M"
		warning "2m - обновляем каждые две минуты"
		warning "2h - обновляем каждые два часа"
		warning "3d - обновляем каждые три дня"
		warning "4w - обновляем каждые четыре недели"
		warning "2M - обновляем каждые два месяц"
	else
		_mins=$(get_period "${1}" "m")
		_hours=$(get_period "${1}" "h")
		_days=$(get_period "${1}" "d")
		_weeks=$(get_period "${1}" "w")
		_months=$(get_period "${1}" "M")
		# shellcheck disable=SC2039
		if [[ "${_mins}" && "${_hours}" ]]; then
			error "Период задать возможно только в одном из форматов:"
			error "в минутах(m), часах(h), днях(d), неделях(w), месяцах(M)."
		else
			del_period_update &>/dev/null
			echo -n "Период обновления "
			if [ -n "${_mins}" ]; then
				echo "0/${_mins} * * * * root ${UPDATE_BIN_FILE} update" >> ${CRONTAB_FILE}
				echo -e "установлен на каждые ${YELLOW}${_mins} мин.${NOCL}"
			elif [ -n "${_hours}" ]; then
				echo "0 */${_hours} * * * root ${UPDATE_BIN_FILE} update" >> ${CRONTAB_FILE}
				echo -e "установлен на каждые ${YELLOW}${_hours} ч.${NOCL}"
			elif [ -n "${_days}" ]; then
				echo "0 * */${_days} * * root ${UPDATE_BIN_FILE} update" >> ${CRONTAB_FILE}
				echo -e "установлен на каждые ${YELLOW}${_days} дн.${NOCL}"
			elif [ -n "${_weeks}" ]; then
				echo "0 * * */${_weeks} * root ${UPDATE_BIN_FILE} update" >> ${CRONTAB_FILE}
				echo -e "установлен на каждые ${YELLOW}${_weeks} нед.${NOCL}"
			elif [ -n "${_months}" ]; then
				echo "0 * * * */${_months} root ${UPDATE_BIN_FILE} update" >> ${CRONTAB_FILE}
				echo -e "установлен на каждые ${YELLOW}${_months} мес.${NOCL}"
			fi
		fi
	fi
}

del_period_update(){
	file_name_sed=$(echo "${UPDATE_BIN_FILE}" | sed 's|/|\\/|g')
	sed -i "/root ${file_name_sed} update/d" "${CRONTAB_FILE}"
	warning "Обновление данных пакета КВАС остановлено."
	warning "Для установки периода обновления запустите 'kvas period'."
}

# ------------------------------------------------------------------------------------------
#
#	 Добавляет указанную гостевую сеть в список маркировки трафика
#	 $1 - тип гостевой сети в терминах entware, например br2
#
# ------------------------------------------------------------------------------------------
vpn_add_guest_network() {

	if ip4 a | grep -qe " ${1}:" ; then
		guest_network_ent="${1}"
		ip_net=$(ip addr show "${guest_network_ent}" | grep -Po "(?<=inet ).*(?=brd)")
		ready "Правила для маркировки гостевой сети ${guest_network_ent} -> ${ip_net} добавлены"
		if cmd_vpn_status | grep -qi shadowsocks ; then
			ip4_add_guest_to_ssr_network
		else
			ip4_add_guest_to_vpn_network
		fi
		[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "С ОШИБКОЙ"
	else
		error "Такой сети '${1}' не существует. "
		error "Проверьте правильность ее написания."
	fi


}

# ------------------------------------------------------------------------------------------
#
#	 Добавляет указанную гостевую сеть в список маркировки трафика
#	 $1 - тип гостевой сети в терминах entware
#
# ------------------------------------------------------------------------------------------
vpn_del_guest_network() {

	if cmd_vpn_status | grep -iq 'shadowsocks' ; then
		error "Сейчас используется shadowsocks соединение."
		error "Удаление гостевой сети для vpn пока не доступно."
	else
		guest_network_ent=$(cat /opt/apps/kvas/bin/libs/ndm | grep INFACE_GUEST_ENT | head -1 | cut -d'=' -f2)
		if [ -n "${guest_network_ent}" ]; then
			ip_net=$(ip addr show "${guest_network_ent}" | grep -Po "(?<=inet ).*(?=brd)")
			ready "Правила для маркировки гостевой сети ${guest_network_ent} -> ${ip_net} удалены"
			ip4_del_guest_to_vpn_network
			[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "С ОШИБКОЙ"
		else
			error "Нечего удалять, гостевой сети не существует."
		fi
	fi
}

cmd_vpn_guest_network() {

	if ! cmd_vpn_status | grep -iq 'shadowsocks' ; then
		cmd="${1}"
		if [ -n "${cmd}" ]; then
			[ "${cmd}" = del ] && vpn_del_guest_network || vpn_add_guest_network "${cmd}"
		else
			guest_network_ent=$(cat /opt/apps/kvas/bin/libs/ndm | grep INFACE_GUEST_ENT | head -1 | cut -d'=' -f2)
			if [ -n "${guest_network_ent}" ]; then
				ip_net=$(ip addr show "${guest_network_ent}" | grep -Po "(?<=inet ).*(?=brd)")
				warning "Текущая гостевая сеть ${guest_network_ent} -> ${ip_net}"
			else
				error "Гостевая сеть НЕ задана!"
			fi
		fi
	else
		error "Сейчас используется shadowsocks соединение."
		error "Добавление гостевой сети для vpn пока не доступно."
	fi
}
